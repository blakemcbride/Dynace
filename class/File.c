/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 30 "File.d"
#ifdef _MSC_VER 
#if _MSC_VER > 1200 
#define _CRT_SECURE_NO_DEPRECATE 
#define _POSIX_ 
#endif 


#line 35 "File.d"
#else 


#line 36 "File.d"
#include <unistd.h> 
#endif 


#line 40 "File.d"
#include <sys/types.h> 
#if !defined(vms) && !defined(__MWERKS__) 
#include <sys/stat.h> 
#endif 


#line 44 "File.d"
#if defined(sparc) || defined(unix) 
#include <unistd.h> 
#endif 


#line 47 "File.d"
#include <time.h> 
#if defined(_MSC_VER) 
#include <direct.h> 
#endif 


#line 52 "File.d"
#include <string.h> 

#define	CLASS	File_c
#define	ivType	File_iv_t

#include "generics.h"

object	File_c;


#line 87 "File.c"
typedef struct  _File_iv_t  {
	object iName;
	FILE * iFP;
	int iTempFile;
	int iFileAlreadyOpened;
}	File_iv_t;


#line 96 "File.c"
typedef struct  _File_cv_t  {
	unsigned int cNumTempFiles;
	char cTempSubDir [ 32 ];
	char cTempFileDir [ 256 ];
	long cProcessID;
}	File_cv_t;

static	File_cv_t	*File_cv;


#line 68 "File.d"
#if defined(unix) || defined(__APPLE__) || defined(__minix) || defined(__HAIKU__) 
#define MKDIR(d) mkdir(d, 0777) 
#else 


#line 71 "File.d"
#define MKDIR(d) mkdir(d) 
#endif 


#line 74 "File.d"
cmeth objrtn File_cm_gNew(object self)
{ 
	return gShouldNotImplement(self, "gNew"); 
} 

PMETHOD objrtn File_initVars(object self, char *name, FILE *fp)
{ File_iv_t *iv = GetIVs(File, self);
	iv->iName = gNewWithStr(String, name); 
	iv->iFP = fp; 
	return self; 
} 

cmeth objrtn File_cm_gNewWithStream(object self, char *name, FILE *fp)
{ 
	object obj = oSuper(File_c, gNew, self)(self); 
	accessIVsOf(obj); 
	iv->iFileAlreadyOpened = 1; 
	return File_initVars(obj, name, fp); 
} 

cmeth objrtn File_cm_gOpenFile(object self, char *name, char *mode)
{ 
	FILE *fp; 

	if (IsObj((object) name)) 
		name = gStringValue((object) name); 
	if (IsObj((object) mode)) 
		mode = gStringValue((object) mode); 
	fp = fopen(name, mode); 
	if (!fp) { 
		gMoreHandles(LowFile); 
		fp = fopen(name, mode); 
	} 
	if (!fp) 
		return NULL; 
	return File_initVars(oSuper(File_c, gNew, self)(self), name, fp); 
} 

PMETHOD objrtn set_temp(object self)
{ File_iv_t *iv = GetIVs(File, self);
	iv->iTempFile = 1; 
	return self; 
} 

cmeth objrtn File_cm_gOpenTempFile(object self)
{ 
	char file[256]; 
	static unsigned tfn = 0; 
	object obj; 

	if (!File_cv->cProcessID) { 
		int len; 
		char tp[256]; 
		static char *pp = NULL; 

		if (!pp) { 
			pp = getenv("TMP"); 
			if (!pp) 
				pp = getenv("TEMP"); 
			if (!pp) 
				pp = "."; 
		} 
		strcpy(tp, pp); 
		len = strlen(tp); 
		if (len >= 1 && tp[len-1] != '\\' && tp[len-1] != '/') { 
#ifdef unix 
			strcat(tp, "/"); 
#else 


#line 142 "File.d"
			strcat(tp, "\\"); 
#endif 


#line 144 "File.d"
		} 




		if (*File_cv->cTempSubDir) { 

			strcat(tp, File_cv->cTempSubDir); 
			MKDIR(tp); 
#ifdef unix 
			strcat(tp, "/"); 
#else 


#line 156 "File.d"
			strcat(tp, "\\"); 
#endif 


#line 158 "File.d"
		} 



#if defined(_WIN32) && !defined(__WINE__) 
		File_cv->cProcessID = GetCurrentProcessId(); 
#else 


#line 165 "File.d"
		File_cv->cProcessID = time(NULL); 
#endif 


#line 176 "File.d"
		sprintf(File_cv->cTempFileDir, "%s%u", tp, (unsigned) File_cv->cProcessID); 
		while (MKDIR(File_cv->cTempFileDir)) 
			sprintf(File_cv->cTempFileDir, "%s%u", tp, (unsigned) ++File_cv->cProcessID); 
	} 
#ifdef unix 
	sprintf(file, "%s/%u-%u.tmp", File_cv->cTempFileDir, (unsigned) File_cv->cProcessID, ++tfn); 
	obj = gOpenFile(self, file, "w+"); 
#else 


#line 184 "File.d"
	sprintf(file, "%s\\%u-%u.tmp", File_cv->cTempFileDir, (unsigned) File_cv->cProcessID, ++tfn); 
	obj = gOpenFile(self, file, "w+b"); 
#endif 


#line 187 "File.d"
	if (obj) { 
		File_cv->cNumTempFiles++; 
		return set_temp(obj); 
	} else 
		return NULL; 
} 

PMETHOD objrtn StreamObject(object self, char *name, FILE *fp)
{ 
	return File_initVars(oSuper(File_c, gNew, self)(self), name, fp); 
} 

PMETHOD objrtn unlinkTempFile(object self, char *name)
{ 
	unlink(name); 
	File_cv->cNumTempFiles--; 

	if (!File_cv->cNumTempFiles) { 
		rmdir(File_cv->cTempFileDir); 
		File_cv->cProcessID = 0L; 
	} 
	return self; 
} 

imeth objrtn File_im_gGCDispose(object self)
{ File_iv_t *iv = GetIVs(File, self);
	fclose(iv->iFP); 
	if (iv->iTempFile && IsObj(iv->iName)) 
		unlinkTempFile(CLASS, gStringValue(iv->iName)); 
	return oSuper(File_c, gDispose, self)(self); 
} 

imeth objrtn File_im_gDispose(object self)
{ File_iv_t *iv = GetIVs(File, self);
	if (!iv->iFileAlreadyOpened) 
		fclose(iv->iFP); 
	if (iv->iTempFile) 
		unlinkTempFile(CLASS, gStringValue(iv->iName)); 
	gDispose(iv->iName); 
	return oSuper(File_c, gDispose, self)(self); 
} 

imeth int File_im_gRead(object self, char *buf, unsigned n)
{ File_iv_t *iv = GetIVs(File, self);
	return fread(buf, 1, n, iv->iFP); 
} 

imeth int File_im_gWrite(object self, char *buf, unsigned n)
{ File_iv_t *iv = GetIVs(File, self);
	return fwrite(buf, 1, n, iv->iFP); 
} 

imeth char * File_im_gGets(object self, char *buf, int sz)
{ File_iv_t *iv = GetIVs(File, self);

	return fgets(buf, sz, iv->iFP); 
} 

imeth long File_im_gAdvance(object self, long n)
{ File_iv_t *iv = GetIVs(File, self);
	int r = fseek(iv->iFP, n, SEEK_CUR); 
	return r ? 0L : n; 
} 

imeth long File_im_gRetreat(object self, long n)
{ File_iv_t *iv = GetIVs(File, self);
	int r = fseek(iv->iFP, -n, SEEK_CUR); 
	return r ? 0L : n; 
} 

imeth long File_im_gSeek(object self, long n)
{ File_iv_t *iv = GetIVs(File, self);
	int r = fseek(iv->iFP, n, SEEK_SET); 
	return r ? 0L : n; 
} 

imeth long File_im_gPosition(object self)
{ File_iv_t *iv = GetIVs(File, self);

	return ftell(iv->iFP); 
} 

imeth long File_im_gLength(object self)
{ File_iv_t *iv = GetIVs(File, self);
#if !defined(vms) && !defined(__MWERKS__) && !defined(PLAN9) 
		struct stat sb; 
	int r; 

	r = fstat(fileno(iv->iFP), &sb); 
	return r ? -1L : sb.st_size; 
#else 

#line 278 "File.d"
		long sav = ftell(iv->iFP); 
	long len; 

	fseek(iv->iFP, 0L, SEEK_END); 
	len = ftell(iv->iFP); 
	fseek(iv->iFP, sav, SEEK_SET); 
	return len; 
#endif 

#line 286 "File.d"
	} 

imeth char * File_im_gName(object self)
{ File_iv_t *iv = GetIVs(File, self);
	return gStringValue(iv->iName); 
} 

imeth int File_im_gEndOfStream(object self)
{ File_iv_t *iv = GetIVs(File, self);
	return feof(iv->iFP); 
} 

imeth void * File_im_gPointerValue(object self)
{ File_iv_t *iv = GetIVs(File, self);
	return (void *) iv->iFP; 
} 

cmeth objrtn File_cm_gSetTempSubDir(object self, char *dir)
{ 
	strcpy(File_cv->cTempSubDir, dir); 
	return self; 
} 

imeth int File_im_gFlush(object self)
{ File_iv_t *iv = GetIVs(File, self);
	return fflush(iv->iFP); 
} 

cmeth int File_cm_gFlush(object self)
{ 
	return fflush(NULL); 
} 

static void class_init(void) 
{ 
	String; 
	stdoutStream_o = StreamObject(CLASS, "stdout", stdout); 
	stderrStream_o = StreamObject(CLASS, "stderr", stderr); 
	stdinStream_o = StreamObject(CLASS, "stdin", stdin); 
	traceStream_o = stdoutStream_o; 
	File_cv->cProcessID = 0L; 
} 

#line 393 "File.c"

objrtn	File_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (File_c) {
		LEAVECRITICALSECTION(cs);
		return File_c;
	}
	INHIBIT_THREADER;
	Stream_initialize();
	if (File_c)  {
		ENABLE_THREADER;
		LEAVECRITICALSECTION(cs);
		return File_c;
	}
	File_c = gNewClass(Class, "File", sizeof(File_iv_t), sizeof(File_cv_t), Stream, END);
	cMethodFor(File, gFlush, File_cm_gFlush);
	cMethodFor(File, gNew, File_cm_gNew);
	cMethodFor(File, gOpenTempFile, File_cm_gOpenTempFile);
	cMethodFor(File, gNewWithStream, File_cm_gNewWithStream);
	cMethodFor(File, gOpenFile, File_cm_gOpenFile);
	cMethodFor(File, gSetTempSubDir, File_cm_gSetTempSubDir);
	iMethodFor(File, gFlush, File_im_gFlush);
	iMethodFor(File, gRetreat, File_im_gRetreat);
	iMethodFor(File, gPosition, File_im_gPosition);
	iMethodFor(File, gLength, File_im_gLength);
	iMethodFor(File, gWrite, File_im_gWrite);
	iMethodFor(File, gEndOfStream, File_im_gEndOfStream);
	iMethodFor(File, gSeek, File_im_gSeek);
	iMethodFor(File, gPointerValue, File_im_gPointerValue);
	iMethodFor(File, gAdvance, File_im_gAdvance);
	iMethodFor(File, gDispose, File_im_gDispose);
	iMethodFor(File, gName, File_im_gName);
	iMethodFor(File, gGets, File_im_gGets);
	iMethodFor(File, gGCDispose, File_im_gGCDispose);
	iMethodFor(File, gDeepDispose, File_im_gDispose);
	iMethodFor(File, gRead, File_im_gRead);

	File_cv = GetCVs(File);

	class_init();

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return File_c;
}




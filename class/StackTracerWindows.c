/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 31 "StackTracerWindows.d"
#ifdef _MSC_VER 
# if _MSC_VER > 1200 
# define _CRT_SECURE_NO_DEPRECATE 
# define _POSIX_ 
# include <windows.h> 
# include <DbgHelp.h> 
# else 
# include <windows.h> 
# include <imagehlp.h> 
# endif 
#else 


#line 42 "StackTracerWindows.d"
# include <windows.h> 
# include <DbgHelp.h> 
#endif 


#line 46 "StackTracerWindows.d"
#include <tchar.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <time.h> 
#include <shlwapi.h> 
#include <fcntl.h> 
#include <sys\types.h> 
#include <sys\stat.h> 
#include <sys\locking.h> 
#include <io.h> 



typedef BOOL (__stdcall * SYMINITIALIZEPROC)( HANDLE, LPSTR, BOOL ); 
typedef BOOL (__stdcall *SYMCLEANUPPROC)( HANDLE ); 

typedef BOOL (__stdcall * STACKWALKPROC)( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID, 
	PREAD_PROCESS_MEMORY_ROUTINE,PFUNCTION_TABLE_ACCESS_ROUTINE, 
	PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE ); 

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, DWORD ); 

typedef DWORD (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, DWORD ); 

typedef BOOL (__stdcall *SYMGETSYMFROMADDRPROC)( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL ); 

typedef BOOL (__stdcall *SYMGETLINEFROMADDRPROC)( HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE ); 

typedef DWORD (__stdcall *SYMSETOPTIONSPROC)( DWORD ); 

#define	CLASS	StackTracer_c
#define	ivType	StackTracer_iv_t

#include "generics.h"

object	StackTracer_c;


#line 98 "StackTracerWindows.c"
typedef struct  _StackTracer_iv_t  {
	LPTOP_LEVEL_EXCEPTION_FILTER iPreviousFilter;
	TCHAR iLogFileName [ MAX_PATH ];
	BOOL iDisplayOn;
	BOOL iLogOn;
	ifun iFunction;
}	StackTracer_iv_t;


#line 108 "StackTracerWindows.c"
typedef struct  _StackTracer_cv_t  {
	object cTracer;
	char cImageName [ 255 ];
	char cPDBPath [ 255 ];
	char cAppName [ 255 ];
	char cImageHlpVersion [ 32 ];
	SYMINITIALIZEPROC _SymInitialize;
	SYMCLEANUPPROC _SymCleanup;
	STACKWALKPROC _StackWalk;
	SYMFUNCTIONTABLEACCESSPROC _SymFunctionTableAccess;
	SYMGETMODULEBASEPROC _SymGetModuleBase;
	SYMGETSYMFROMADDRPROC _SymGetSymFromAddr;
	SYMGETLINEFROMADDRPROC _SymGetLineFromAddr;
	SYMSETOPTIONSPROC _SymSetOptions;
}	StackTracer_cv_t;

static	StackTracer_cv_t	*StackTracer_cv;


#line 103 "StackTracerWindows.d"
static int command_line_error_handler(char *msg); 

static int lock_file(char *file) 
{ 
	int h; 
	char buf[256]; 

	sprintf(buf, "%s.lck", file); 
	h = open(buf, _O_CREAT | _O_TRUNC |_O_WRONLY, _S_IREAD | _S_IWRITE); 
	if (h == -1) 
		return h; 
	lseek(h, 0L, SEEK_SET); 
	_locking(h, _LK_LOCK, 1L); 
	return h; 
} 

static void unlock_file(int h) 
{ 
	if (h != -1) { 
		lseek(h, 0L, SEEK_SET); 
		_locking(h, _LK_UNLCK, 1L); 
	} 
} 

#define MIN_SIZE 60000 
#define MAX_SIZE 1000000 

PMETHOD void pLogMessage(object self, LPCTSTR pszMessage)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	int h, lf; 
	struct _stat sb; 

	if (iv->iLogOn == FALSE) 
		return; 
	lf = lock_file(iv->iLogFileName); 
	if (!_stat(iv->iLogFileName, &sb) && sb.st_size > MAX_SIZE) { 
		int h2; 
		char *buf, tmpfile[256], *p; 

		if (!(h = open(iv->iLogFileName, _O_BINARY | _O_RDONLY))) { 
			unlock_file(lf); 
			return; 
		} 
		sprintf(tmpfile, "%s.tmp", iv->iLogFileName); 
		if (!(h2 = open(tmpfile, _O_TRUNC | _O_CREAT | _O_BINARY | _O_WRONLY, _S_IREAD | _S_IWRITE))) { 
			close(h); 
			unlock_file(lf); 
			return; 
		} 
		buf = malloc(MIN_SIZE+10); 
		lseek(h, -MIN_SIZE, SEEK_END); 
		read(h, buf, MIN_SIZE); 
		buf[MIN_SIZE] = '\0'; 
		for (p=buf ; *p && (p[0] != '/' || p[1] != '/' || p[2] != ' ' || p[3] != '=' || p[4] != '=') ; p++); 
		write(h2, p, strlen(p)); 
		close(h); 
		close(h2); 
		free(buf); 
		unlink(iv->iLogFileName); 
		rename(tmpfile, iv->iLogFileName); 
	} 

	h = open(iv->iLogFileName, _O_APPEND | _O_CREAT | _O_TEXT | _O_WRONLY, _S_IREAD | _S_IWRITE); 
	if (h != -1) { 
		write(h, pszMessage, strlen(pszMessage)); 
		close(h); 
	} 
	unlock_file(lf); 
} 

static void init_class() 
{ 
	HMODULE hModImagehlp = LoadLibrary( _T("DBGHELP.DLL") ); 
	DLLGETVERSIONPROC proc; 
	StackTracer_cv->cTracer = gNew(StackTracer); 

	if ( !hModImagehlp ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "LoadLibrary() for imagehlp.dll failed."); 
		return; 
	} 

	GetModuleFileName(hModImagehlp, StackTracer_cv->cImageName, sizeof(StackTracer_cv->cImageName)); 

	proc = (DLLGETVERSIONPROC)GetProcAddress(hModImagehlp, "DllGetVersion"); 
	if (proc) 
	{ 
		DLLVERSIONINFO info; 
		info.cbSize = sizeof(info); 
		proc(&info); 
		sprintf(StackTracer_cv->cImageHlpVersion, "%ld,%ld,%ld", info.dwMajorVersion, info.dwMinorVersion, info.dwBuildNumber); 
	} 
	else 
	{ 
		strcpy(StackTracer_cv->cImageHlpVersion, "Unknown"); 
	} 

	StackTracer_cv->_SymInitialize = (SYMINITIALIZEPROC)GetProcAddress( hModImagehlp, 
		"SymInitialize" ); 
	if ( !StackTracer_cv->_SymInitialize ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "SymInitialize address not found."); 
		return; 
	} 

	StackTracer_cv->_SymCleanup = (SYMCLEANUPPROC)GetProcAddress( hModImagehlp, "SymCleanup" ); 
	if ( !StackTracer_cv->_SymCleanup ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "SymCleanup address not found."); 
		return; 
	} 

	StackTracer_cv->_StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" ); 
	if ( !StackTracer_cv->_StackWalk ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "StackWalk address not found."); 
		return; 
	} 

	StackTracer_cv->_SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC) 
		GetProcAddress( hModImagehlp, "SymFunctionTableAccess" ); 

	if ( !StackTracer_cv->_SymFunctionTableAccess ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "SymFunctionTableAccess address not found."); 
		return; 
	} 

	StackTracer_cv->_SymGetModuleBase = (SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp, 
		"SymGetModuleBase"); 
	if ( !StackTracer_cv->_SymGetModuleBase ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "SymGetModuleBase address not found."); 
		return; 
	} 

	StackTracer_cv->_SymGetSymFromAddr = (SYMGETSYMFROMADDRPROC)GetProcAddress( hModImagehlp, 
		"SymGetSymFromAddr" ); 
	if ( !StackTracer_cv->_SymGetSymFromAddr ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "SymGetSymFromAddr address not found."); 
		return; 
	} 

	StackTracer_cv->_SymGetLineFromAddr = (SYMGETLINEFROMADDRPROC)GetProcAddress( hModImagehlp, 
		"SymGetLineFromAddr" ); 

#line 257 "StackTracerWindows.d"
	StackTracer_cv->_SymSetOptions = (SYMSETOPTIONSPROC)GetProcAddress( hModImagehlp, 
		"SymSetOptions" ); 
	if ( !StackTracer_cv->_SymSetOptions ) 
	{ 
		pLogMessage(StackTracer_cv->cTracer, "SymSetOptions address not found."); 
		return; 
	} 
	gSetErrorFunction(Object, command_line_error_handler); 
} 

imeth void StackTracer_im_gSetLogOn(object self, int bOn)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	iv->iLogOn = bOn; 
} 

imeth void StackTracer_im_gSetDisplayOn(object self, int bOn)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	iv->iDisplayOn = bOn; 
} 

imeth int StackTracer_im_gIsLogOn(object self)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	return iv->iLogOn; 
} 

imeth int StackTracer_im_gIsDisplayOn(object self)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	return iv->iDisplayOn; 
} 

imeth objrtn StackTracer_im_gGetLogFileName(object self)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	return gNewWithStr(String, iv->iLogFileName); 
}

#line 290 "StackTracerWindows.d"
; 

imeth objrtn StackTracer_im_gSetLogFileName(object self, char *logFileName)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	strcpy(iv->iLogFileName, logFileName); 
	return self; 
} 

cmeth objrtn StackTracer_cm_gGetTracer(object self)
{ 
	return StackTracer_cv->cTracer; 
} 

static LONG WINAPI ST_UnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo ); 

cmeth objrtn StackTracer_cm_gNew(object self)
{ 
	PTSTR pszDot; 
	object obj = oSuper(StackTracer_c, gNew, self)(self); 
	ivType *iv = ivPtr(obj); 

	iv->iDisplayOn = FALSE; 
	iv->iLogOn = TRUE; 


	iv->iPreviousFilter = SetUnhandledExceptionFilter(ST_UnhandledExceptionFilter); 


	GetModuleFileName( 0, iv->iLogFileName, MAX_PATH ); 
	strcpy(StackTracer_cv->cPDBPath, iv->iLogFileName); 
	strcpy(StackTracer_cv->cAppName, iv->iLogFileName); 

	*(_tcsrchr(StackTracer_cv->cPDBPath, _T('\\')) + 1) = 0x00; 



	pszDot = _tcsrchr( iv->iLogFileName, _T('.') ); 
	if ( pszDot ) 
	{ 
		pszDot++; 
		if ( _tcslen(pszDot) >= 3 ) 
		{ 
			_tcscpy( pszDot, _T("stackdump.txt") ); 
		} 
	} 

	return obj; 
} 

imeth objrtn StackTracer_im_gDispose(object self)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	SetUnhandledExceptionFilter( iv->iPreviousFilter ); 
	return oSuper(StackTracer_c, gDispose, self)(self); 
} 

PMETHOD void pDisplayMessage(object self, LPCTSTR pszMessage)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	if (iv->iDisplayOn) 

		if (iv->iFunction) 
		iv->iFunction(pszMessage); 
} 

static int command_line_error_handler(char *msg) 
{ 
	gStackDump(gGetTracer(StackTracer), msg); 
	return 0; 
} 

imeth ofun StackTracer_im_gSetFunction(object self, int (*fun)())
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	ofun ret = (ofun) iv->iFunction; 
	iv->iFunction = fun; 
	return ret; 
} 

PMETHOD LPTSTR pGetExceptionString( object self, DWORD dwCode)
{ 
#define EXCEPTION( x ) case EXCEPTION_##x: return _T(#x); 

	switch ( dwCode ) 
	{ 
		EXCEPTION( ACCESS_VIOLATION ) 
			EXCEPTION( DATATYPE_MISALIGNMENT ) 
			EXCEPTION( BREAKPOINT ) 
			EXCEPTION( SINGLE_STEP ) 
			EXCEPTION( ARRAY_BOUNDS_EXCEEDED ) 
			EXCEPTION( FLT_DENORMAL_OPERAND ) 
			EXCEPTION( FLT_DIVIDE_BY_ZERO ) 
			EXCEPTION( FLT_INEXACT_RESULT ) 
			EXCEPTION( FLT_INVALID_OPERATION ) 
			EXCEPTION( FLT_OVERFLOW ) 
			EXCEPTION( FLT_STACK_CHECK ) 
			EXCEPTION( FLT_UNDERFLOW ) 
			EXCEPTION( INT_DIVIDE_BY_ZERO ) 
			EXCEPTION( INT_OVERFLOW ) 
			EXCEPTION( PRIV_INSTRUCTION ) 
			EXCEPTION( IN_PAGE_ERROR ) 
			EXCEPTION( ILLEGAL_INSTRUCTION ) 
			EXCEPTION( NONCONTINUABLE_EXCEPTION ) 
			EXCEPTION( STACK_OVERFLOW ) 
			EXCEPTION( INVALID_DISPOSITION ) 
			EXCEPTION( GUARD_PAGE ) 
			EXCEPTION( INVALID_HANDLE ) 
		} 

	return NULL; 
} 

PMETHOD BOOL pGetLogicalAddress(object self, LPCVOID addr, PTSTR szModule, DWORD len, DWORD *section, DWORD *offset)
{ 
	MEMORY_BASIC_INFORMATION mbi; 
	INT_PTR hMod; 
	PIMAGE_DOS_HEADER pDosHdr; 
	PIMAGE_NT_HEADERS pNtHdr; 
	INT_PTR rva; 
	PIMAGE_SECTION_HEADER pSection; 
	unsigned i; 


	__try 
	{ 

		if ( !VirtualQuery( addr, &mbi, (SIZE_T)sizeof(mbi) ) ) 
			return FALSE; 

		hMod = (INT_PTR) mbi.AllocationBase; 

		if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) ) 
			return FALSE; 


		pDosHdr = (PIMAGE_DOS_HEADER)hMod; 



		pNtHdr = (PIMAGE_NT_HEADERS)((char *)hMod + pDosHdr->e_lfanew); 

		pSection = IMAGE_FIRST_SECTION( pNtHdr ); 

		rva = (INT_PTR)addr - hMod; 



		for (i = 0; 
		i < pNtHdr->FileHeader.NumberOfSections; 
		i++, pSection++ ) 
		{ 
			INT_PTR sectionStart = pSection->VirtualAddress; 
			INT_PTR sectionEnd = sectionStart 
				+ max(pSection->SizeOfRawData, pSection->Misc.VirtualSize); 


			if ( (rva >= sectionStart) && (rva <= sectionEnd) ) 
			{ 



				*section = i+1; 
				*offset = rva - sectionStart; 
				return TRUE; 
			} 
		} 
	} 
	__except(EXCEPTION_EXECUTE_HANDLER) 
	{ 
	} 

	return FALSE; 
} 

PMETHOD void pImagehlpStackWalk(object self, LPTSTR szText, PCONTEXT pContext)
{ 
#ifndef _M_X64 
		STACKFRAME sf; 

	_tcscat(szText, _T("\n") ); 
	memset( &sf, 0, sizeof(sf) ); 



	sf.AddrPC.Offset = pContext->Eip; 
	sf.AddrPC.Mode = AddrModeFlat; 
	sf.AddrStack.Offset = pContext->Esp; 
	sf.AddrStack.Mode = AddrModeFlat; 
	sf.AddrFrame.Offset = pContext->Ebp; 
	sf.AddrFrame.Mode = AddrModeFlat; 

	while ( 1 ) { 
		DWORD dwTempDis = 0; 
		BYTE symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ]; 
		PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer; 
		DWORD symDisplacement = 0; 

		IMAGEHLP_LINE line; 

		if ( ! StackTracer_cv->_StackWalk( IMAGE_FILE_MACHINE_I386, 
			GetCurrentProcess(), 
			GetCurrentThread(), 
			&sf, 
			pContext, 
			0, 
			StackTracer_cv->_SymFunctionTableAccess, 
			StackTracer_cv->_SymGetModuleBase, 
			0 ) ) 
			break; 

		if ( 0 == sf.AddrFrame.Offset ) 
			break; 
#line 508 "StackTracerWindows.d"
		pSymbol->SizeOfStruct = sizeof(symbolBuffer); 
		pSymbol->MaxNameLength = 512; 

		line.SizeOfStruct = sizeof(line); 

		if ( StackTracer_cv->_SymGetSymFromAddr(GetCurrentProcess(), sf.AddrPC.Offset, 
			&symDisplacement, pSymbol)) 
		{ 
			_stprintf(szText + _tcslen(szText), _T("%hs() "), pSymbol->Name); 
		} 

		if (StackTracer_cv->_SymGetLineFromAddr) 
		{ 
#line 525 "StackTracerWindows.d"
			dwTempDis = 0; 
			while ( FALSE == StackTracer_cv->_SymGetLineFromAddr (GetCurrentProcess(), 
				sf.AddrPC.Offset - dwTempDis, &symDisplacement, &line) ) 
			{ 
				dwTempDis += 1 ; 
				if ( 100 == dwTempDis ) 
					break; 
			} 

		} 


		if (StackTracer_cv->_SymGetLineFromAddr && dwTempDis < 100) 
		{ 
			char fname[_MAX_FNAME]; 
			char ext[_MAX_EXT]; 

			_splitpath(line.FileName, NULL, NULL, fname, ext); 
			_stprintf(szText + _tcslen(szText), _T("in %hs%hs line %ld\n"), fname, ext, line.LineNumber); 
		} 
		else 
		{ 
			TCHAR szModule[MAX_PATH] = _T(""); 
			DWORD section = 0, offset = 0; 
			char fname[_MAX_FNAME]; 
			char ext[_MAX_EXT]; 

			if (pGetLogicalAddress(self, (PVOID)sf.AddrPC.Offset, 
				szModule, sizeof(szModule), &section, &offset )) 
			{ 
				_splitpath(szModule, NULL, NULL, fname, ext); 

				_stprintf(szText + _tcslen(szText), _T("%04X:%08X %s%s\n"), 
					section, offset, fname, ext ); 
			} 
			else 
			{ 
				_tcscat(szText, _T(" Unrecognized file format in stackframe.\n")); 
			} 
		} 
	} 
#endif 

#line 567 "StackTracerWindows.d"
	} 

PMETHOD void pGenerateExceptionReport(object self, LPTSTR szText, PEXCEPTION_POINTERS pExceptionInfo)
{ 
	PEXCEPTION_RECORD pExceptionRecord = pExceptionInfo->ExceptionRecord; 
	TCHAR szFaultingModule[MAX_PATH]; 
	DWORD section, offset; 
	PCONTEXT pCtx = pExceptionInfo->ContextRecord; 

	if (StackTracer_cv->_SymSetOptions == 0) 
	{ 
		strcpy(szText, "Unable to load imagehlp.dll\n"); 
		return; 
	} 

	StackTracer_cv->_SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES); 

	if ( !StackTracer_cv->_SymInitialize( GetCurrentProcess(), StackTracer_cv->cPDBPath, TRUE ) ) 
	{ 
		LPVOID lpMsgBuf; 
		FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS, 
			NULL, 
			GetLastError(), 
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
			(LPTSTR) &lpMsgBuf, 
			0, 
			NULL 
			); 
		_stprintf(szText + _tcslen(szText), "SymInitialize Error: %s\n", (char *)lpMsgBuf); 
		if (lpMsgBuf) 
			LocalFree( lpMsgBuf ); 
		return; 
	} 

	_stprintf(szText + _tcslen(szText), _T("Exception code: %08X %s\n"), 
		pExceptionRecord->ExceptionCode, 
		pGetExceptionString(self, pExceptionRecord->ExceptionCode) ); 


	pGetLogicalAddress(self, pExceptionRecord->ExceptionAddress, 
		szFaultingModule, 
		sizeof( szFaultingModule ), 
		&section, &offset ); 

	pImagehlpStackWalk(self, szText, pCtx ); 
	StackTracer_cv->_SymCleanup(GetCurrentProcess()); 
	_tcscat(szText, _T("\n") ); 
} 

PMETHOD LONG pExecutePrevious(object self, PEXCEPTION_POINTERS pExceptionInfo)
{ StackTracer_iv_t *iv = GetIVs(StackTracer, self);
	if ( iv->iPreviousFilter ) 
		return iv->iPreviousFilter( pExceptionInfo ); 
	else 
		return EXCEPTION_CONTINUE_SEARCH; 
} 

static LONG WINAPI ST_UnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionInfo ) 
{ 
	TCHAR szText[64000]; 
	object tracer = gGetTracer(StackTracer); 
	char szTime[128]; 
	char szDate[128]; 

	__try 
	{ 
		sprintf(szText, "// =====================================================\nDateTime: %s:%s\nAppName: %s\nImagehlp: %s (%s)\n\n", _strdate(szDate), _strtime(szTime), StackTracer_cv->cAppName, StackTracer_cv->cImageName, StackTracer_cv->cImageHlpVersion); 

		pGenerateExceptionReport(tracer, szText, pExceptionInfo ); 

		pLogMessage(tracer, szText); 
		pDisplayMessage(tracer, szText); 
	} 
	__except(EXCEPTION_EXECUTE_HANDLER) 
	{ 
		sprintf(szText, "// =====================================================\nDateTime: %s:%s\nAppName: %s\nImagehlp: %s (%s)\n\n", _strdate(szDate), _strtime(szTime), StackTracer_cv->cAppName, StackTracer_cv->cImageName, StackTracer_cv->cImageHlpVersion); 
		strcat(szText, "Exception while building exception report."); 
		pLogMessage(StackTracer_cv->cTracer, szText); 
	} 

	return pExecutePrevious(tracer, pExceptionInfo); 

} 

PMETHOD void pCopyPointers(object self, PEXCEPTION_POINTERS pIn, PEXCEPTION_POINTERS pOut)
{ 
	memcpy(pOut->ContextRecord, pIn->ContextRecord, sizeof(CONTEXT)); 
	memcpy(pOut->ExceptionRecord, pIn->ExceptionRecord, sizeof(EXCEPTION_RECORD)); 
} 

PMETHOD void pGetStackDumpText(object self, LPTSTR szText)
{ 
	EXCEPTION_POINTERS ptrs; 
	EXCEPTION_RECORD rec; 
	CONTEXT context; 

	ptrs.ContextRecord = &context; 
	ptrs.ExceptionRecord = &rec; 

	__try 
	{ 
		memcpy(0, 0, 1); 

	} 
	__except(pCopyPointers(self, GetExceptionInformation(), &ptrs),1) 
	{ 
		pGenerateExceptionReport(self, szText, &ptrs); 
	} 
} 

imeth objrtn StackTracer_im_gGetStackDumpText(object self)
{ 
	TCHAR szText[64000]; 
	pGetStackDumpText(self, szText); 
	return gNewWithStr(String, szText); 
} 

imeth void StackTracer_im_gStackDump(object self, char *pszMessage)
{ 
	TCHAR szText[64000]; 
	char szTime[128]; 
	char szDate[128]; 

	sprintf(szText, "// =====================================================\nDateTime: %s:%s\nAppName: %s\nImagehlp: %s (%s)\n\n", _strdate(szDate), _strtime(szTime), StackTracer_cv->cAppName, StackTracer_cv->cImageName, StackTracer_cv->cImageHlpVersion); 

	if (pszMessage) 
	{ 
		_tcscat(szText, pszMessage); 
		_tcscat(szText, "\n\n"); 
	} 

	pGetStackDumpText(self, szText); 

	pLogMessage(self, szText); 
	pDisplayMessage(self, szText); 
} 


#line 722 "StackTracerWindows.c"

objrtn	StackTracer_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (StackTracer_c) {
		LEAVECRITICALSECTION(cs);
		return StackTracer_c;
	}
	INHIBIT_THREADER;
	StackTracer_c = gNewClass(Class, "StackTracer", sizeof(StackTracer_iv_t), sizeof(StackTracer_cv_t), END);
	cMethodFor(StackTracer, gGetTracer, StackTracer_cm_gGetTracer);
	cMethodFor(StackTracer, gNew, StackTracer_cm_gNew);
	iMethodFor(StackTracer, gStackDump, StackTracer_im_gStackDump);
	iMethodFor(StackTracer, gSetFunction, StackTracer_im_gSetFunction);
	iMethodFor(StackTracer, gSetDisplayOn, StackTracer_im_gSetDisplayOn);
	iMethodFor(StackTracer, gIsLogOn, StackTracer_im_gIsLogOn);
	iMethodFor(StackTracer, gGetLogFileName, StackTracer_im_gGetLogFileName);
	iMethodFor(StackTracer, gSetLogFileName, StackTracer_im_gSetLogFileName);
	iMethodFor(StackTracer, gSetLogOn, StackTracer_im_gSetLogOn);
	iMethodFor(StackTracer, gDispose, StackTracer_im_gDispose);
	iMethodFor(StackTracer, gGetStackDumpText, StackTracer_im_gGetStackDumpText);
	iMethodFor(StackTracer, gDeepDispose, StackTracer_im_gDispose);
	iMethodFor(StackTracer, gIsDisplayOn, StackTracer_im_gIsDisplayOn);

	StackTracer_cv = GetCVs(StackTracer);

	init_class();

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return StackTracer_c;
}




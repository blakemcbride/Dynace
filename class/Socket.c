/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 32 "Socket.d"
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#define USE_FCNTL 
#endif 


#line 37 "Socket.d"
#ifdef _MSC_VER 
#if _MSC_VER > 1200 
#define _CRT_SECURE_NO_DEPRECATE 
#define _POSIX_ 
#endif 


#line 42 "Socket.d"
#endif 


#line 44 "Socket.d"
#include <stdio.h> 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
#include <winsock.h> 
#endif 


#line 48 "Socket.d"
#include <stdlib.h> 
#ifdef __WINE__ 
#else 


#line 51 "Socket.d"
#include <errno.h> 
#endif 


#line 53 "Socket.d"
#include <string.h> 
#include <ctype.h> 
#include <time.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#include <unistd.h> 
#include <netdb.h> 
#include <netinet/in.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <arpa/inet.h> 
#endif 


#line 67 "Socket.d"
#ifdef USE_FCNTL 
#include <fcntl.h> 
#endif 


#line 72 "Socket.d"
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#define closesocket close 
#define ioctlsocket ioctl 
#define SOCKET int 
#define INVALID_SOCKET -1 
#define SOCKET_ERROR -1 
#define WSAEINTR EINTR 
#define WSAEWOULDBLOCK EWOULDBLOCK 
#define TRUE 1 
#endif 


#line 84 "Socket.d"
#define BACKLOG 20 

#ifdef MY_SSL 
#include "ssleay.h" 

struct SSL_SOCKET { 
	short int flag; 
	union { 
		SSL* ssfd; 
		SOCKET sfd; 
	} SSL_union; 
}; 


typedef struct SSL_SOCKET G_SOCKET; 

#define CLIENT_VERIFY_OPTION SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT 




#define SSL_HANDSHAKE_MAX_WAIT 500 
#define MAX_OF_HANDSHAKES 2400 

#define CERTF "PEM\\PEM_CLI\\clicert.pem" 
#define KEYF "PEM\\PEM_CLI\\clikey.pem" 

#define CAfile "PEM\\PEM_CA\\cacert.pem" 
#define CApath ".\\PEM\\PEM_CA" 

#define SERVER_AUTH_CLIENT 0 



static int s_server_verify=SSL_VERIFY_NONE; 



#else 


#line 123 "Socket.d"
typedef SOCKET G_SOCKET; 

typedef int SSL_CTX; 
#endif 


#define	CLASS	Socket_c
#define	ivType	Socket_iv_t

#include "generics.h"

object	Socket_c;


#line 167 "Socket.c"
typedef struct  _Socket_iv_t  {
	G_SOCKET iFP;
	struct sockaddr_in iAddress;
	int iVerifyError;
	SSL_CTX * iCtx;
	char * iCipher;
	int iServerAuthClient;
	int iServerSSL;
	long iTotalBytesRead;
}	Socket_iv_t;


#line 180 "Socket.c"
typedef struct  _Socket_cv_t  {
	int cNumbInstances;
	int cError;
	char * cErrorStr;
}	Socket_cv_t;

static	Socket_cv_t	*Socket_cv;


#line 149 "Socket.d"
#ifdef MY_SSL 
static int init_Server_SSL_CTX(ivType *iv); 
static int SSL_Server_Handshake(ivType *iv, SSL* ssl); 
static int verify_callback(int ok, X509_STORE_CTX *ctx); 
static int verify_depth=1; 
static int verify_error=X509_V_OK; 
#endif 


#line 158 "Socket.d"
#define t_makeword(a, b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) << 8)) 
#define MAX_WAIT 120 
#define SMALLBUFLEN 256 
#define BUFLEN 2048 

static int initSockets(void); 
static int is_ip_address(char *s); 
static int what_error(void); 
static void sleepInMilliSeconds(unsigned time); 

static int updateErrorStr(char * strBuf); 
static object decrementUsage(void); 
static int sufSSLConnect(ivType *iv, SOCKET sockfd, short int flag); 


#ifdef MY_SSL 
static int init_Client_SSL_CTX(ivType *iv); 
static int init_SSL(ivType *iv, SSL** pssl, SOCKET sockfd); 
static int SSL_Client_Handshake(ivType* iv, SSL* ssl); 
static int set_cert_stuff(SSL_CTX* ctx, char* cert_file, char* key_file); 
static int verify_Server(ivType* iv, SSL* ssl); 

static void print_stats(SSL_CTX* ssl_ctx); 
static void print_Server_Certificate(SSL* ssl); 

#endif 


#line 186 "Socket.d"
cmeth objrtn Socket_cm_gNew(object self)
{ 
	return gShouldNotImplement(self, "gNew"); 
} 

#line 198 "Socket.d"
static int initSockets() 
{ 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
	WORD wVersionRequested; 
	WSADATA wsaData; 
	int err; 
	char strBuf[SMALLBUFLEN]; 

	if (!Socket_cv->cNumbInstances) { 
		memset(&wsaData,0,sizeof(wsaData)); 
		wVersionRequested = t_makeword(1, 1); 

		if(WSAStartup(wVersionRequested, &wsaData)!=0) { 
			err=WSAGetLastError(); 

			Socket_cv->cError = 1; 
			sprintf(strBuf, "unable to start WINSOCK (cError) in initSockets(), error code=%d.",err); 
			updateErrorStr(strBuf); 
			return 0; 
		} 

#line 224 "Socket.d"
	} 
#endif 


#line 226 "Socket.d"
	return 1; 
} 




cmeth objrtn Socket_cm_gSocketConnect(object self, char *addr, int port, short int flag)
{ 
	return gProxyConnect(self, addr, port, flag, NULL, 0, NULL, NULL); 
} 
static object errorReturn(object obj, int e, char *msg) 
{ 
	Socket_cv->cError = e; 
	updateErrorStr(msg); 
	return gDispose(obj); 
} 

cmeth objrtn Socket_cm_gProxyConnect(object self, char *addr, int port, short int flag, char *proxy_addr, int proxy_port, char *proxy_user, char *proxy_pw)
{ 

	struct hostent *he = NULL; 
	struct sockaddr_in their_addr; 
	int isip, isproxy = !!proxy_addr; 
	SOCKET sockfd; 
	char strBuf[SMALLBUFLEN]; 
	object obj; 
	ivType *iv; 

	if (!Socket_cv->cNumbInstances && !initSockets()) 
		return NULL; 

	Socket_cv->cNumbInstances++; 

	isip = is_ip_address(addr); 

	if (!isip) 
		if ((he=gethostbyname(addr)) == NULL) { 
		Socket_cv->cError = 2; 
		sprintf(strBuf, "Invalid IP address (cError) in gSocketConnect."); 
		updateErrorStr(strBuf); 
		return decrementUsage(); 
	} 


	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) { 
		Socket_cv->cError = 3; 
		sprintf(strBuf, "INVALID_SOCKET (cError=3) in gSocketConnect."); 
		updateErrorStr(strBuf); 
		return decrementUsage(); 
	} 

	memset(&their_addr, 0, sizeof their_addr); 
	their_addr.sin_family = AF_INET; 
	their_addr.sin_port = htons((unsigned short) (isproxy ? proxy_port : port)); 
	if (isip || isproxy) 
		their_addr.sin_addr.s_addr = inet_addr(isproxy ? proxy_addr : addr); 
	else 
		their_addr.sin_addr = *((struct in_addr *)he->h_addr); 

	if (connect(sockfd, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == SOCKET_ERROR) { 
		Socket_cv->cError = 4; 
		sprintf(strBuf, "SOCKET_ERROR (cError=4) in gSocketConnect."); 
		updateErrorStr(strBuf); 
		closesocket(sockfd); 
		return decrementUsage(); 
	} 

#ifdef USE_FCNTL 
	{ 
		int flags = fcntl(sockfd, F_GETFL, 0); 
		if (flags < 0) { 
			Socket_cv->cError = 5; 
			sprintf(strBuf, "flags<0 (cError=5) in gSocketConnect."); 
			updateErrorStr(strBuf); 
			closesocket(sockfd); 
			return decrementUsage(); 
		} 

		flags |= O_NONBLOCK; 
		if (fcntl(sockfd, F_SETFL, flags) < 0) { 
			Socket_cv->cError = 6; 
			sprintf(strBuf, "flags<0 (cError=6) in gSocketConnect."); 
			updateErrorStr(strBuf); 
			closesocket(sockfd); 
			return decrementUsage(); 
		} 
	} 
#else 


#line 314 "Socket.d"
	{ 
		ULONG flg = TRUE; 
		if (ioctlsocket(sockfd, FIONBIO, &flg) == SOCKET_ERROR) { 
			Socket_cv->cError = 7; 
			sprintf(strBuf, "SOCKET_ERROR (cError=7) in gSocketConnect."); 
			updateErrorStr(strBuf); 
			closesocket(sockfd); 
			return decrementUsage(); 
		} 
	} 
#endif 


#line 326 "Socket.d"
	obj = oSuper(Socket_c, gNew, self)(self); 
	iv = ivPtr(obj); 
	Socket_cv->cError = 0; 

	if (isproxy) { 
		unsigned char c, buf[81]; 
		int i = 0, r; 
		unsigned short dport = htons((unsigned short) port); 

#ifdef MY_SSL 
		iv->iFP.SSL_union.sfd = sockfd; 
#else 


#line 338 "Socket.d"
		iv->iFP = sockfd; 
#endif 


#line 341 "Socket.d"
		if (proxy_user) { 
#if 1 
			if (4 != gWrite(obj, "\x05\x02\x00\x02", 4)) 
				return errorReturn(obj, 8, "write error 1"); 
			if (2 != (r=gRead(obj, (char *)buf, 2))) 
				return errorReturn(obj, 8, "read error 1"); 
			if (buf[1] && buf[1] != 2) 
				return errorReturn(obj, 8, "Proxy authentication other than name/password required"); 
#else 


#line 350 "Socket.d"
			if (5 != gWrite(obj, "\x05\x03\x00\x01\x02", 5)) 
				return errorReturn(obj, 8, "write error 1"); 
			if (2 != (r=gRead(obj, (char *)buf, 2))) 
				return errorReturn(obj, 8, "read error 1"); 
			if (buf[1] && buf[1] != 2 && buf[1] != 1) 
				return errorReturn(obj, 8, "Proxy authentication other than GSSAPI and name/password required"); 
			if (buf[1] == 1) 
				return errorReturn(obj, 8, "Proxy authentication GSSAPI required"); 
#endif 


#line 359 "Socket.d"
			if (buf[1]) { 
				buf[0] = 1; 
				buf[1] = strlen(proxy_user); 
				strcpy((char *)buf+2, proxy_user); 
				if (buf[1]+2 != gWrite(obj, (char *)buf, buf[1]+2)) 
					return errorReturn(obj, 8, "write error 7"); 
				buf[0] = proxy_pw ? strlen(proxy_pw) : 0; 
				if (proxy_pw) 
					strcpy((char *)buf+1, proxy_pw); 
				if (buf[0]+1 != gWrite(obj, (char *)buf, buf[0]+1)) 
					return errorReturn(obj, 8, "write error 8"); 
				if (2 != (r=gRead(obj, (char *)buf, 2))) 
					return errorReturn(obj, 8, "read error 8"); 
				if (buf[1]) 
					return errorReturn(obj, 8, "Proxy username/password not accepted"); 
			} 
		} else { 
			if (3 != gWrite(obj, "\x05\x01\x00", 3)) 
				return errorReturn(obj, 8, "write error 1"); 
			if (2 != (r=gRead(obj, (char *)buf, 2))) 
				return errorReturn(obj, 8, "read error 1"); 
			if (buf[1]) 
				return errorReturn(obj, 8, "Proxy authentication required"); 
		} 

		if (3 != gWrite(obj, "\x05\x01\x00", 3)) 
			return errorReturn(obj, 8, "write error 2"); 
		if (isip) { 
			unsigned long ad = inet_addr(addr); 
			c = '\x01'; 
			if (1 != gWrite(obj, (char *)&c, 1)) 
				return errorReturn(obj, 8, "write error 3"); 
			if (4 != gWrite(obj, (char *) &ad, 4)) 
				return errorReturn(obj, 8, "write error 4"); 
		} else { 
			buf[0] = '\x03'; 
			strcpy((char *)buf+2, addr); 
			buf[1] = strlen((char *)buf+2); 
			if ((int) buf[1] + 2 != gWrite(obj, (char *)buf, (int) buf[1] + 2)) 
				return errorReturn(obj, 8, "write error 5"); 
		} 
		if (2 != gWrite(obj, (char *) &dport, 2)) 
			return errorReturn(obj, 8, "write error 6"); 
		if (4 != gRead(obj, (char *)buf, 4)) 
			return errorReturn(obj, 8, "read error 2"); 
		if (buf[1]) 
			return errorReturn(obj, 8, "general SOCKS server failure"); 
		if (buf[3] == 1) { 
			if (6 != gRead(obj, (char *)buf, 6)) 
				return errorReturn(obj, 8, "read error 3"); 
		} else if (buf[3] == 3) { 
			if (1 != gRead(obj, (char *)&c, 1)) 
				return errorReturn(obj, 8, "read error 4"); 
			if (c+2 != gRead(obj, (char *)buf, c+2)) 
				return errorReturn(obj, 8, "read error 5"); 
		} else if (buf[3] == 4) { 
			if (18 != gRead(obj, (char *)buf, 18)) 
				return errorReturn(obj, 8, "read error 6"); 
		} else 
			return errorReturn(obj, 8, "invalid ATYP"); 
	} 

	if (!sufSSLConnect(iv, sockfd, flag)) 
		return gDispose(obj); 

	return obj; 
} 

static int sufSSLConnect(ivType *iv, SOCKET sockfd, short int flag) 
{ 
#ifdef MY_SSL 
	iv->iVerifyError = X509_V_OK; 

	iv->iCipher = NULL; 
	iv->iCtx = NULL; 

	iv->iFP.flag = flag; 

	if (iv->iFP.flag == 0) 
		iv->iFP.SSL_union.sfd = sockfd; 
	else { 
		if (!init_Client_SSL_CTX(iv)) 
			return 0; 

		if (!init_SSL(iv, &iv->iFP.SSL_union.ssfd, sockfd)) 
			return 0; 

		if (!SSL_Client_Handshake(iv, iv->iFP.SSL_union.ssfd)) 
			return 0; 
	} 
#else 


#line 450 "Socket.d"
	iv->iFP = sockfd; 
#endif 


#line 452 "Socket.d"
	return 1; 
} 

imeth objrtn Socket_im_gDispose(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	SOCKET sockfd=0; 


#ifdef MY_SSL 
		if (iv->iFP.flag != 1) 
		sockfd = iv->iFP.SSL_union.sfd; 
	else { 
		if (iv->iFP.SSL_union.ssfd != NULL) { 
			sockfd = SSL_get_fd(iv->iFP.SSL_union.ssfd); 
			SSL_free(iv->iFP.SSL_union.ssfd); 
			iv->iFP.SSL_union.ssfd = NULL; 
		} 

		if (iv->iCtx) { 
			SSL_CTX_free(iv->iCtx); 
			iv->iCtx = NULL; 
		} 
	} 
	if (sockfd) 
		closesocket(sockfd); 
#else 

#line 478 "Socket.d"
		if (iv->iFP) 
		closesocket(iv->iFP); 
#endif 

#line 481 "Socket.d"
		decrementUsage(); 
	return oSuper(Socket_c, gDispose, self)(self); 
} 

imeth int Socket_im_gRead(object self, char *buf, unsigned n)
{ 
	return gTimedRead(self, buf, n, MAX_WAIT); 
} 

imeth int Socket_im_gTimedRead(object self, char *buf, unsigned n, int max_wait)
{ 
	return gTimedReadMS(self, buf, n, max_wait, 0L); 
} 

imeth int Socket_im_gTimedReadMS(object self, char *buf, unsigned n, int max_wait, long microsec_wait)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	unsigned tot = 0; 
	int t, e; 

	SOCKET sfd; 

#ifdef MY_SSL 
		SSL* ssl=NULL; 
	if(iv->iFP.flag==0) { 
		sfd=iv->iFP.SSL_union.sfd; 
	} 
	else { 
		ssl = iv->iFP.SSL_union.ssfd; 
		sfd=SSL_get_fd(ssl); 
	} 
#else 

#line 512 "Socket.d"
		sfd=iv->iFP; 
#endif 


#line 515 "Socket.d"
		while (n) { 
#ifdef MY_SSL 
			if (iv->iFP.flag) 
			t = SSL_read(ssl, buf, n); 
		else 
			t = recv(sfd, buf, n, 0); 
#else 

#line 522 "Socket.d"
			t = recv(sfd, buf, n, 0); 
#endif 


#line 525 "Socket.d"
			if (t < 0) 
			if ((e=what_error()) == WSAEINTR) 
			t = 0; 
		else if (e == WSAEWOULDBLOCK) { 
			fd_set setRead; 
			struct timeval timeout; 
			FD_ZERO(&setRead); 

			FD_SET(sfd, &setRead); 
			timeout.tv_sec = max_wait; 
			timeout.tv_usec = microsec_wait; 
			t = select(sfd+1, &setRead, NULL, NULL, &timeout); 
#line 542 "Socket.d"
			if (t <= 0) 
				return -1; 
			t = 0; 
		} else 
			return t; 
		else if (!t) 
			break; 
		tot += t; 
		buf += t; 
		n -= t; 
		iv->iTotalBytesRead += t; 
	} 
	return tot; 
} 



imeth int Socket_im_gWrite(object self, char *buf, unsigned n)
{ 
	return gTimedWrite(self, buf, n, MAX_WAIT); 
} 

imeth int Socket_im_gWriteInt32(object self, int val)
{ 
	uint32_t network_val; 

	network_val = htonl(val); 
	return gWrite(self, (char *)&network_val, sizeof(network_val)); 
} 

imeth int Socket_im_gReadInt32(object self, int *val)
{ 
	uint32_t network_val; 

	if (gRead(self, (char *)&network_val, sizeof(network_val)) != sizeof(network_val)) 
		return 0; 
	*val = ntohl(network_val); 
	return 1; 
} 


imeth int Socket_im_gTimedWrite(object self, char *buf, unsigned n, int max_wait)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	unsigned tot = 0; 
	int t, e; 
	SOCKET sfd; 

#ifdef MY_SSL 
		SSL* ssl=NULL; 
	if(iv->iFP.flag==0) { 
		sfd=iv->iFP.SSL_union.sfd; 
	} 
	else { 
		ssl = iv->iFP.SSL_union.ssfd; 
		sfd=SSL_get_fd(ssl); 
	} 
#else 

#line 599 "Socket.d"
		sfd = iv->iFP; 
#endif 


#line 602 "Socket.d"
		while (n) { 
#ifdef MY_SSL 
			if (iv->iFP.flag) 
			t = SSL_write(ssl, buf, n); 
		else 
			t = send(sfd, buf, n, 0); 
#else 

#line 609 "Socket.d"
			t = send(sfd, buf, n, 0); 
#endif 


#line 612 "Socket.d"
			if (t <= 0) 
			if ((e=what_error()) == WSAEINTR) 
			t = 0; 
		else if (e == WSAEWOULDBLOCK) { 
			fd_set setWrite; 
			struct timeval timeout; 
			FD_ZERO(&setWrite); 
			FD_SET(sfd, &setWrite); 
			timeout.tv_sec = max_wait; 
			timeout.tv_usec = 0; 
			t = select(sfd+1, NULL, &setWrite, NULL, &timeout); 
			if (t <= 0) 
				return -1; 
			t = 0; 
		} else 
			return t; 
		tot += t; 
		buf += t; 
		n -= t; 
	} 
	return tot; 
} 


cmeth int Socket_cm_gGetErrorCode(object self)
{ 
	return Socket_cv->cError; 
} 


cmeth char * Socket_cm_gGetErrorStr(object self)
{ 
	return Socket_cv->cErrorStr; 
} 

#line 652 "Socket.d"
static int is_ip_address(char *s) 
{ 
	int dots = 0; 

	for ( ; *s ; s++) 
		if (*s == '.') 
		dots++; 
	else if (!isdigit(*s)) 
		return 0; 
	return dots == 3; 
} 



#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#define MODE "" 
#else 


#line 669 "Socket.d"
#define MODE "b" 
#endif 


#line 672 "Socket.d"
extern unsigned long BufCRC(unsigned long crc, char *buf, int size); 
extern unsigned long InitCRC(void); 

#define SEND(x) if (sizeof(x) != gWrite(self, (char *) &x, sizeof(x))) goto er1 
#define RECV(x) if (sizeof(x) != gRead(self, (char *) &x, sizeof(x))) goto er1 

#line 683 "Socket.d"
imeth int Socket_im_gSendStr(object self, char *str)
{ 
	char buf[80]; 
	strcpy(buf, str); 
	return 80!=gWrite(self, buf, sizeof(buf)); 
} 


#line 696 "Socket.d"
imeth int Socket_im_gSendFile(object self, char *fromFile, char *toFile)
{ 
	FILE *fp = fopen(fromFile, "r" MODE); 
	uint32_t size, crc, crc2; 
	struct stat sb; 
	int len; 
	uint16_t nlen, code = htons(1); 
	char buf[BUFLEN]; 

	if (!fp) 
		return 1; 
	if (fstat(fileno(fp), &sb)) 
		goto er1; 
	size = htonl(sb.st_size); 
	crc = InitCRC(); 

	fseek(fp, 0L, SEEK_SET); 
	SEND(code); 
	SEND(size); 

	if (!toFile) 
		toFile = fromFile; 
	len = strlen(toFile) + 1; 
	nlen = htons((short)len); 
	SEND(nlen); 
	if (len != gWrite(self, toFile, len)) 
		goto er1; 

	while ((len = fread(buf, 1, BUFLEN, fp)) > 0) 
		if (len != gWrite(self, buf, len)) 
		goto er1; 
	else 
		crc = BufCRC(crc, buf, len); 
	if (ferror(fp)) 
		goto er1; 
	crc = htonl(crc); 
	SEND(crc); 
	RECV(crc2); 
	if (crc != crc2) 
		goto er1; 
	fclose(fp); 
	return 0; 
	er1: 
	fclose(fp); 
	return -1; 
} 


#line 748 "Socket.d"
imeth int Socket_im_gGetStr(object self, char *str)
{ 
	char buf[80]; 
	int r = gRead(self, buf, 80); 
	if (r != 80) 
		return 1; 
	buf[79] = '\0'; 
	strcpy(str, buf); 
	return 0; 
} 


#line 766 "Socket.d"
imeth int Socket_im_gRecvFile(object self, char *toFile)
{ 
	FILE *fp = fopen(toFile, "w" MODE); 
	uint32_t size, crc, crc2; 
	int len; 
	uint16_t nlen, code; 
	char buf[BUFLEN]; 

	if (!fp) 
		return 1; 
	crc = InitCRC(); 

	RECV(code); 
	if (code != htons(1)) 
		goto er1; 

	RECV(size); 
	size = ntohl(size); 

	RECV(nlen); 
	len = ntohs(nlen); 
	if (len && len != gRead(self, buf, len)) 
		goto er1; 

	while (size) { 
		unsigned rlen; 

		rlen = size > BUFLEN ? BUFLEN : size; 
		len = gRead(self, buf, rlen); 
		if (len < 0) 
			goto er1; 
		crc = BufCRC(crc, buf, len); 
		if (len != fwrite(buf, 1, len, fp)) 
			goto er1; 
		size -= len; 
	} 

	crc = htonl(crc); 
	RECV(crc2); 
	SEND(crc); 
	if (crc != crc2) 
		goto er1; 
	fclose(fp); 
	return 0; 
	er1: 
	fclose(fp); 
	unlink(toFile); 
	return -1; 
} 

imeth long Socket_im_gGetTotalBytesRead(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	return iv->iTotalBytesRead; 
} 

static object decrementUsage() 
{ 
	if (Socket_cv->cNumbInstances && !--Socket_cv->cNumbInstances) 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
	WSACancelBlockingCall(), 
		WSACleanup() 
#endif 


#line 828 "Socket.d"
	; 
	return NULL; 
} 


static int what_error() 
{ 
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
	return errno; 
#else 


#line 838 "Socket.d"
	return WSAGetLastError(); 
#endif 


#line 840 "Socket.d"
} 



static int updateErrorStr(char * strBuf) 
{ 
	if (Socket_cv->cErrorStr) { 
		free(Socket_cv->cErrorStr); 
		Socket_cv->cErrorStr = NULL; 
	} 

	Socket_cv->cErrorStr = (char *)malloc(strlen(strBuf)+1); 
	if (Socket_cv->cErrorStr) { 
		strcpy(Socket_cv->cErrorStr, strBuf); 
		return 1; 
	} else { 
		Socket_cv->cError = -9999; 
		return 0; 
	} 
} 

#line 867 "Socket.d"
static void sleepInMilliSeconds(unsigned time) 
{ 
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
	struct timeval tval; 
	tval.tv_sec = time/1000; 
	tval.tv_usec = time%1000; 
	select(0, NULL, NULL, NULL, &tval); 

#else 


#line 876 "Socket.d"
	Sleep(time); 
#endif 


#line 878 "Socket.d"
} 



imeth char * Socket_im_gGetPeerCertificateIssuerName(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char* retStr=NULL; 
	char buf[SMALLBUFLEN]; 
#ifdef MY_SSL 
		X509 *peer=NULL; 
	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		retStr = (char *)malloc(strlen(buf)+1); 
		strcpy(retStr, buf); 
	} 
	else{ 
		peer=SSL_get_peer_certificate(iv->iFP.SSL_union.ssfd); 

		if (peer != NULL) { 
			X509_NAME_oneline(X509_get_issuer_name(peer),buf,SMALLBUFLEN); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr,buf); 
			X509_free(peer); 

		} 
		else { 
			strcpy(buf,"No peer certificate"); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
	} 
#else 

#line 910 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	retStr = (char *)malloc(strlen(buf)+1); 
	strcpy(retStr, buf); 
#endif 

#line 914 "Socket.d"
		return retStr; 
} 



imeth char * Socket_im_gGetPeerCertificateSubjectName(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char* retStr=NULL; 
	char buf[SMALLBUFLEN]; 

#ifdef MY_SSL 
		X509 *peer=NULL; 
	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		retStr = (char *)malloc(strlen(buf)+1); 
		strcpy(retStr, buf); 
	} 
	else{ 
		peer=SSL_get_peer_certificate(iv->iFP.SSL_union.ssfd); 

		if (peer != NULL) { 
			X509_NAME_oneline(X509_get_subject_name(peer),buf,SMALLBUFLEN); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr,buf); 
			X509_free(peer); 
		} 
		else { 
			strcpy(buf, "No peer certificate"); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
	} 
#else 

#line 947 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	retStr = (char *)malloc(strlen(buf)+1); 
	strcpy(retStr, buf); 
#endif 

#line 951 "Socket.d"
		return retStr; 
} 



imeth int Socket_im_gHowManyBitsOfPeerPublicKey(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#ifdef MY_SSL 
		X509* peer=NULL; 
	int i; 
	if(iv->iFP.flag == 0) { 
		return -1; 
	} 
	else{ 
		peer=SSL_get_peer_certificate(iv->iFP.SSL_union.ssfd); 
		if (peer != NULL) { 
			i = EVP_PKEY_bits(X509_get_pubkey(peer)); 
			X509_free(peer); 
			return i; 
		} 
		else { 
			return -1; 
		} 
	} 
#else 

#line 976 "Socket.d"
		return -1; 
#endif 

#line 978 "Socket.d"
	} 



imeth char * Socket_im_gGetCipher(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char* retStr=NULL; 
	char buf[SMALLBUFLEN]; 
#ifdef MY_SSL 
		SSL_CIPHER* c; 
	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		retStr = (char *)malloc(strlen(buf)+1); 
		strcpy(retStr, buf); 
	} 
	else{ 
		c=SSL_get_current_cipher(iv->iFP.SSL_union.ssfd); 
		if (c != NULL) { 
			strcpy(buf, SSL_CIPHER_get_version(c)); 
			strcat(buf, ": "); 
			strcat(buf, SSL_CIPHER_get_name(c)); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
		else { 
			strcpy(buf,"No peer certificate"); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
	} 
#else 

#line 1009 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	retStr = (char *)malloc(strlen(buf)+1); 
	strcpy(retStr, buf); 
#endif 

#line 1013 "Socket.d"
		return retStr; 
} 



imeth objrtn Socket_im_gGetSessionInfo(object self, char **session1, char **session2, char **session3)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char buf[SMALLBUFLEN]; 


#ifdef MY_SSL 
		int i; 
	char str[128],*s; 
	SSL_SESSION *x; 

	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		*session1 = (char *)malloc(strlen(buf)+1); 
		strcpy(*session1, buf); 
		*session2 = NULL; 
		*session3 = NULL; 
	} 
	else { 
		x = SSL_get_session(iv->iFP.SSL_union.ssfd); 

		if (x != NULL) { 


			if (x->ssl_version == SSL2_VERSION) 
				s="SSLv2"; 
			else if (x->ssl_version == SSL3_VERSION) 
				s="SSLv3"; 
			else if (x->ssl_version == TLS1_VERSION) 
				s="TLSv1"; 
			else 
				s="unknown"; 
			sprintf(str, "    Protocol:      %s\n", s); 
			strcpy(buf, str); 

			sprintf(str,"    Cipher:         %s\n",(x->cipher == NULL)?"unknown":x->cipher->name); 
			strcat(buf, str); 

			strcat(buf,"    Session-ID:  "); 
			for (i=0; i<(int)x->session_id_length; i++){ 
				sprintf(str,"%02X",x->session_id[i]); 
				strcat(buf, str); 
			} 
			strcat(buf,"\n"); 

			*session1 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session1, buf); 



			strcpy(buf,"    Master-Key: "); 
			for (i=0; i<(int)x->master_key_length; i++) { 
				sprintf(str,"%02X",x->master_key[i]); 
				strcat(buf, str); 
			} 
			strcat(buf,"\n"); 

			*session2 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session2, buf); 



			strcpy(buf, "    Key-Arg:       "); 
			if (x->key_arg_length == 0) 
				strcat(buf,"None"); 
			else { 
				for (i=0; i<(int)x->key_arg_length; i++) { 
					sprintf(str,"%02X",x->key_arg[i]); 
					strcat(buf,str); 
				} 
			} 

			strcat(buf, "\n"); 

			if (x->time != 0L){ 
				struct tm * tmTime; 
				char timeStr[30]; 
				tmTime = localtime((time_t*)&(x->time)); 
				strcpy(timeStr, asctime(tmTime)); 
				timeStr[24]=' '; 
				timeStr[25] = 0; 
				sprintf(str,"    Start Time:   %s", timeStr); 
				strcat(buf,str); 
			} 
			strcat(buf, "\n"); 

			if (x->timeout != 0L){ 
				sprintf(str,"    Timeout:      %d (Sec)", x->timeout); 
				strcat(buf, str); 
			} 

			*session3 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session3, buf); 
		} 
		else { 
			strcpy(buf, "Session error"); 
			*session1 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session1, buf); 
			*session2 = NULL; 
			*session3 = NULL; 
		} 
	} 
#else 

#line 1120 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	*session1 = (char *)malloc(strlen(buf)+1); 
	strcpy(*session1, buf); 
	*session2 = NULL; 
	*session3 = NULL; 
#endif 

#line 1126 "Socket.d"
		return self; 
} 

#line 1133 "Socket.d"
static SOCKET makeServer(int port) 
{ 
	struct sockaddr_in serv_addr; 
	SOCKET listen_sd; 


	if (!Socket_cv->cNumbInstances && !initSockets()) 
		return -1; 

	Socket_cv->cNumbInstances++; 

	if ((listen_sd = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
		return -1; 
	memset(&serv_addr, 0, sizeof(serv_addr)); 
	serv_addr.sin_family = AF_INET; 
	serv_addr.sin_port = htons((unsigned short) port); 
	serv_addr.sin_addr.s_addr = INADDR_ANY; 
	if (bind(listen_sd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr)) == SOCKET_ERROR) { 
		closesocket(listen_sd); 
		return -1; 
	} 
	if (listen(listen_sd, BACKLOG) == SOCKET_ERROR) { 
		closesocket(listen_sd); 
		return -1; 
	} 
	return listen_sd; 
} 

#line 1165 "Socket.d"
cmeth objrtn Socket_cm_gMakeServer(object self, int port, int ssl)
{ 
	object obj = oSuper(Socket_c, gNew, self)(self); 
	ivType *iv = ivPtr(obj); 

#ifdef MY_SSL 
	if (iv->iFP.flag = ssl) { 
		iv->iServerSSL = ssl; 
		if (-1 == init_Server_SSL_CTX(iv)) 
			return NULL; 
	} 
	iv->iFP.SSL_union.sfd = makeServer(port); 
#else 


#line 1178 "Socket.d"
	iv->iFP = makeServer(port); 
#endif 


#line 1180 "Socket.d"
	return obj; 
} 


PMETHOD objrtn newSock(object self, SOCKET newsock, int flag, int ssl, struct sockaddr_in *addr)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#ifdef MY_SSL 
		iv->iFP.flag = flag; 
	iv->iFP.SSL_union.sfd = newsock; 
	iv->iServerSSL = ssl; 
#else 

#line 1191 "Socket.d"
		iv->iFP = newsock; 
#endif 

#line 1193 "Socket.d"
		iv->iAddress = *addr; 
	++Socket_cv->cNumbInstances; 
	return self; 
} 

imeth unsigned long Socket_im_gIPAddress(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	return iv->iAddress.sin_addr.s_addr; 
} 

imeth char * Socket_im_gIPAddressStr(object self, char *buf)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
		char *addr = inet_ntoa(iv->iAddress.sin_addr); 
	strcpy(buf, addr); 
#else 

#line 1209 "Socket.d"
		sprintf(buf, "%d.%d.%d.%d", 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b1, 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b2, 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b3, 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b4); 
#endif 

#line 1215 "Socket.d"
		return buf; 
} 





imeth objrtn Socket_im_gAccept(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	struct sockaddr_in client_addr; 
	int sin_size = sizeof(struct sockaddr_in); 
	SOCKET newsock; 
#ifdef MY_SSL 
		SOCKET sockfd = iv->iFP.SSL_union.sfd; 
	int flag = iv->iFP.flag; 
#else 

#line 1231 "Socket.d"
		SOCKET sockfd = iv->iFP; 
	int flag = 0; 
#endif 


#line 1235 "Socket.d"
		newsock = accept(sockfd, (struct sockaddr *)&client_addr, (unsigned int *)&sin_size); 
	if (newsock == INVALID_SOCKET) { 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
			int e = WSAGetLastError(); 
#endif 

#line 1240 "Socket.d"
			return NULL; 
	} 
#ifdef USE_FCNTL 
	{ 
		int flags = fcntl(newsock, F_GETFL, 0); 

		if (flags < 0) { 
			closesocket(newsock); 
			return NULL; 
		} 


		flags |= O_NONBLOCK; 
		if (fcntl(newsock, F_SETFL, flags) < 0) { 
			closesocket(newsock); 
			return NULL; 
		} 
	} 
#else 

#line 1259 "Socket.d"
	{ 
		ULONG flg = TRUE; 
		if (ioctlsocket(newsock, FIONBIO, &flg) == SOCKET_ERROR) { 
			closesocket(newsock); 
			return NULL; 
		} 
	} 
#endif 




#line 1270 "Socket.d"
		return newSock(oSuper(Socket_c, gNew, CLASS)(CLASS), newsock, flag, iv->iServerSSL, &client_addr); 
} 

imeth objrtn Socket_im_gServerSocketConnect(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#ifdef MY_SSL 
		int tmp; 
	SOCKET sockfd; 
	G_SOCKET gs; 
	SSL* ssl = NULL; 

	if (iv->iServerSSL) { 
		gs.flag = iv->iServerSSL; 
		tmp = init_SSL(iv, &ssl, iv->iFP.SSL_union.sfd); 
		if (tmp == -1) 
			return NULL; 
		tmp = SSL_Server_Handshake(iv, ssl); 
		if (tmp == -1) 
			return NULL; 
		gs.SSL_union.ssfd = ssl; 
		iv->iFP = gs; 
	} 
#endif 

#line 1293 "Socket.d"
		return self; 
} 



#ifdef MY_SSL 

static int init_SSL(ivType *iv, SSL** pssl, SOCKET sockfd) 
{ 
	char strBuf[SMALLBUFLEN]; 
	*pssl = (SSL *)SSL_new(iv->iCtx); 


	if(*pssl == NULL) { 
		Socket_cv->cError = 11; 
		sprintf(strBuf, "init_Client_SSL: ssl=NULL (cError=11) in init_SSL"); 
		updateErrorStr(strBuf); 
		return 0; 
	} 

	SSL_set_fd(*pssl, sockfd); 
	SSL_set_connect_state(*pssl); 
	return 1; 
} 

static int set_cert_stuff(SSL_CTX* ctx, char* cert_file, char* key_file) 
{ 
	char strBuf[SMALLBUFLEN]; 
	if (cert_file != NULL) 
	{ 
		if (SSL_CTX_use_certificate_file(ctx,cert_file, SSL_FILETYPE_PEM) <= 0) 
		{ 
			Socket_cv->cError = 14; 
			sprintf(strBuf, "unable to get certificate from '%s' (cError=14) in set_cert_stuff", cert_file); 
			updateErrorStr(strBuf); 
			return 0; 
		} 

		if (key_file == NULL) key_file=cert_file; 
		if (SSL_CTX_use_PrivateKey_file(ctx,key_file, SSL_FILETYPE_PEM) <= 0) 
		{ 
			Socket_cv->cError = 15; 
			sprintf(strBuf, "unable to get private key from '%s' (cError=15) in set_cert_stuff", key_file); 
			updateErrorStr(strBuf); 
			return 0; 
		} 



		if (!SSL_CTX_check_private_key(ctx)) 
		{ 
			Socket_cv->cError = 16; 
			sprintf(strBuf, "Private key does not match the certificate public key (cError=16) in set_cert_stuff"); 
			updateErrorStr(strBuf); 
			return 0; 
		} 
	} 
	return 1; 
} 



static int verify_Server(ivType* iv, SSL* ssl) 
{ 
	char strBuf[SMALLBUFLEN]; 

	iv->iVerifyError=SSL_get_verify_result(ssl); 

	switch (iv->iVerifyError) 
	{ 
		case X509_V_OK: 
		return 1; 
		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: 
		Socket_cv->cError = 17; 
		sprintf(strBuf, "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT (cError=17) in verify_Server"); 


		break; 
		case X509_V_ERR_CERT_NOT_YET_VALID: 
		Socket_cv->cError = 18; 
		sprintf(strBuf, "X509_V_ERR_CERT_NOT_YET_VALID (cError=18) in verify_Server"); 
		break; 
		case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: 
		Socket_cv->cError = 19; 
		sprintf(strBuf, "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD (cError=19) in verify_Server"); 


		break; 
		case X509_V_ERR_CERT_HAS_EXPIRED: 
		Socket_cv->cError = 20; 
		sprintf(strBuf, "X509_V_ERR_CERT_HAS_EXPIRED (cError=20) in verify_Server"); 
		break; 
		case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: 
		Socket_cv->cError = 21; 
		sprintf(strBuf, "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD (cError=21) in verify_Server"); 


		break; 
		default: 
		Socket_cv->cError = 22; 
		sprintf(strBuf, "verify server error (cError=22) in verify_Server"); 
	} 

	updateErrorStr(strBuf); 
	return 0; 
} 

#line 1467 "Socket.d"
static void print_stats(SSL_CTX* ssl_ctx) 
{ 
	printf("%4ld items in the session cache\n", SSL_CTX_sess_number(ssl_ctx)); 
	printf("%4d client connects (SSL_connect())\n", SSL_CTX_sess_connect(ssl_ctx)); 
	printf("%4d client renegotiates (SSL_connect())\n", SSL_CTX_sess_connect_renegotiate(ssl_ctx)); 
	printf("%4d client connects that finished\n", SSL_CTX_sess_connect_good(ssl_ctx)); 
	printf("%4d server accepts (SSL_accept())\n", SSL_CTX_sess_accept(ssl_ctx)); 
	printf("%4d server renegotiates (SSL_accept())\n", SSL_CTX_sess_accept_renegotiate(ssl_ctx)); 
	printf("%4d server accepts that finished\n", SSL_CTX_sess_accept_good(ssl_ctx)); 
	printf("%4d session cache hits\n",SSL_CTX_sess_hits(ssl_ctx)); 
	printf("%4d session cache misses\n",SSL_CTX_sess_misses(ssl_ctx)); 
	printf("%4d session cache timeouts\n",SSL_CTX_sess_timeouts(ssl_ctx)); 
	printf("%4d callback cache hits\n",SSL_CTX_sess_cb_hits(ssl_ctx)); 
	printf("%4d cache full overflows (%d allowed)\n", SSL_CTX_sess_cache_full(ssl_ctx), 
		SSL_CTX_sess_get_cache_size(ssl_ctx)); 
} 



static int init_Client_SSL_CTX(ivType *iv) 
{ 
	int off = 0; 
	SSL_METHOD* meth = NULL; 
	char strBuf[SMALLBUFLEN]; 

	meth = SSLv2_client_method(); 


	SSLeay_add_ssl_algorithms(); 
	SSL_load_error_strings(); 

	iv->iCtx = SSL_CTX_new (meth); 
	if(!iv->iCtx) { 
		Socket_cv->cError = 8; 
		sprintf(strBuf, "iCtx=NULL (cError=8) in init_Client_SSL_CTX."); 
		updateErrorStr(strBuf); 
		return 0; 
	} 

#line 1510 "Socket.d"
	SSL_CTX_set_options(iv->iCtx, SSL_OP_ALL|off); 



	if(SERVER_AUTH_CLIENT) { 
		if (!set_cert_stuff(iv->iCtx, CERTF, KEYF)) { 
			Socket_cv->cError = 9; 
			sprintf(strBuf, "Client certificate and key not matched (cError=9) in init_Client_SSL_CTX.\n"); 
			strcat(strBuf, Socket_cv->cErrorStr); 
			updateErrorStr(strBuf); 
			return 0; 
		} 
	} 

	if (iv->iCipher != NULL) 
		SSL_CTX_set_cipher_list(iv->iCtx, iv->iCipher); 
	else 
		iv->iCipher=getenv("SSL_CIPHER"); 

	if (!SSL_CTX_load_verify_locations(iv->iCtx,CAfile,CApath)) 
	{ 
		Socket_cv->cError = 10; 
		sprintf(strBuf, "Load CA certificate error (cError=10) in init_Client_SSL_CTX."); 
		updateErrorStr(strBuf); 
		return 0; 
	} 



	return 1; 
} 



static int SSL_Client_Handshake(ivType* iv, SSL* ssl) 
{ 
	unsigned long int tmp; 
	char strBuf[SMALLBUFLEN]; 
	int t1; 




	tmp=0; 

	while(SSL_in_init(ssl)) 
	{ 

		if(tmp++ > MAX_OF_HANDSHAKES) { 
			Socket_cv->cError = 12; 
			sprintf(strBuf, "SSL hadshake fails (cError=12): ssl in state %d %s", 
				tmp, SSL_state_string_long(ssl)); 
			updateErrorStr(strBuf); 
			return 0; 
		} 


		SSL_connect(ssl); 

		sleepInMilliSeconds(SSL_HANDSHAKE_MAX_WAIT); 
	} 




	if( !verify_Server(iv, ssl) ) 
		return 0; 

	return 1; 
} 

#line 1588 "Socket.d"
static void print_Server_Certificate(SSL* ssl) 
{ 
	char buf[BUFLEN]; 
	X509* server_cert; 


	printf ("SSL connection using %s\n", SSL_get_cipher (ssl)); 



	server_cert = SSL_get_peer_certificate (ssl); 

	if (server_cert != NULL) { 
		printf ("Server certificate:\n"); 

		X509_NAME_oneline (X509_get_subject_name (server_cert), buf, BUFLEN); 
		printf ("\t subject: %s\n", buf); 

		X509_NAME_oneline (X509_get_issuer_name (server_cert), buf, BUFLEN); 
		printf ("\t issuer: %s\n", buf); 




		X509_free (server_cert); 
	} else 
		printf ("Server does not have certificate.\n"); 
} 

static int init_Server_SSL_CTX(ivType *iv) 
{ 
	int off=0; 

	SSL_METHOD* meth=NULL; 


	SSL_load_error_strings(); 
	SSLeay_add_ssl_algorithms(); 

	meth = SSLv2_method(); 

#line 1633 "Socket.d"
	off|=SSL_OP_NO_SSLv2; 
	off|=SSL_OP_NO_TLSv1; 

	iv->iCtx = SSL_CTX_new (meth); 
	if (iv->iCtx == NULL) 
	{ 

		return -1; 
	} 

	SSL_CTX_set_quiet_shutdown(iv->iCtx,1); 
	SSL_CTX_set_options(iv->iCtx, off); 
	SSL_CTX_sess_set_cache_size(iv->iCtx, 128); 

	if (!set_cert_stuff(iv->iCtx, CERTF, KEYF)) 
		return (-1); 


	if (iv->iCipher != NULL) 
		SSL_CTX_set_cipher_list(iv->iCtx, iv->iCipher); 




	if(iv->iServerAuthClient) { 
		if (!SSL_CTX_load_verify_locations(iv->iCtx,CAfile,CApath)) 
		{ 

			return -1; 
		} 
	} 

#line 1670 "Socket.d"
	if(iv->iServerAuthClient) { 
		SSL_CTX_set_verify(iv->iCtx,s_server_verify,verify_callback); 
		SSL_CTX_set_client_CA_list(iv->iCtx, SSL_load_client_CA_file(CAfile)); 
	} 

	return 0; 
} 

static int SSL_Server_Handshake(ivType *iv, SSL* ssl) 
{ 
	unsigned int tmp; 

#line 1687 "Socket.d"
	tmp=0; 

	while(SSL_in_init(ssl)) 
	{ 

		if(tmp++ > MAX_OF_HANDSHAKES) { 
			printf("\nSSL hadshake fails\n"); 
			printf("ssl state %d: %s\n", tmp, SSL_state_string_long(ssl)); 
			return -1; 
		} 

		SSL_accept(ssl); 

		sleepInMilliSeconds(SSL_HANDSHAKE_MAX_WAIT); 
	} 



	if (iv->iServerAuthClient) { 
		verify_error=SSL_get_verify_result(ssl); 

		if (verify_error != X509_V_OK) 
		{ 


			return (-1); 
		} 


	} 

	return 0; 
} 

#line 1727 "Socket.d"
#if 0 
static void print_Client_Certificate(SSL* ssl) 
{ 
	char buf[SMALL_BUF_LEN]; 
	X509* client_cert; 

	printf ("SSL connection using %s\n", SSL_get_cipher (ssl)); 



	client_cert = SSL_get_peer_certificate (ssl); 
	if (client_cert != NULL) { 
		printf ("Client certificate:\n"); 

		X509_NAME_oneline (X509_get_subject_name (client_cert), buf, SMALL_BUF_LEN); 
		printf ("\t subject: %s\n", buf); 

		X509_NAME_oneline (X509_get_issuer_name (client_cert), buf, SMALL_BUF_LEN); 
		printf ("\t issuer: %s\n", buf); 




		X509_free (client_cert); 
	} else 
		printf ("Client does not have certificate.\n"); 
} 
#endif 


#line 1756 "Socket.d"
static int verify_callback(int ok, X509_STORE_CTX *ctx) 
{ 
	char buf[256]; 
	X509 *err_cert; 
	int err,depth; 

	err_cert=X509_STORE_CTX_get_current_cert(ctx); 
	err= X509_STORE_CTX_get_error(ctx); 
	depth= X509_STORE_CTX_get_error_depth(ctx); 

	X509_NAME_oneline(X509_get_subject_name(err_cert),buf,256); 

	if (!ok) 
	{ 


		if (verify_depth >= depth) 
		{ 
			ok=1; 
			verify_error=X509_V_OK; 
		} 
		else 
		{ 
			ok=0; 
			verify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG; 
		} 
	} 
	switch (ctx->error) 
	{ 
		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: 
		X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256); 

		break; 
		case X509_V_ERR_CERT_NOT_YET_VALID: 
		case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: 


		printf("X509_V_ERR_CERT_NOT_YET_VALID\n"); 
		break; 
		case X509_V_ERR_CERT_HAS_EXPIRED: 
		case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: 


		printf("X509_V_ERR_CERT_HAS_EXPIRED\n"); 
		break; 
	} 

	return(ok); 
} 

#endif 


#line 1830 "Socket.c"

objrtn	Socket_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (Socket_c) {
		LEAVECRITICALSECTION(cs);
		return Socket_c;
	}
	INHIBIT_THREADER;
	Stream_initialize();
	if (Socket_c)  {
		ENABLE_THREADER;
		LEAVECRITICALSECTION(cs);
		return Socket_c;
	}
	Socket_c = gNewClass(Class, "Socket", sizeof(Socket_iv_t), sizeof(Socket_cv_t), Stream, END);
	cMethodFor(Socket, gGetErrorCode, Socket_cm_gGetErrorCode);
	cMethodFor(Socket, gProxyConnect, Socket_cm_gProxyConnect);
	cMethodFor(Socket, gNew, Socket_cm_gNew);
	cMethodFor(Socket, gGetErrorStr, Socket_cm_gGetErrorStr);
	cMethodFor(Socket, gSocketConnect, Socket_cm_gSocketConnect);
	cMethodFor(Socket, gMakeServer, Socket_cm_gMakeServer);
	iMethodFor(Socket, gServerSocketConnect, Socket_im_gServerSocketConnect);
	iMethodFor(Socket, gTimedRead, Socket_im_gTimedRead);
	iMethodFor(Socket, gWrite, Socket_im_gWrite);
	iMethodFor(Socket, gGetSessionInfo, Socket_im_gGetSessionInfo);
	iMethodFor(Socket, gRecvFile, Socket_im_gRecvFile);
	iMethodFor(Socket, gAccept, Socket_im_gAccept);
	iMethodFor(Socket, gGetPeerCertificateSubjectName, Socket_im_gGetPeerCertificateSubjectName);
	iMethodFor(Socket, gHowManyBitsOfPeerPublicKey, Socket_im_gHowManyBitsOfPeerPublicKey);
	iMethodFor(Socket, gSendFile, Socket_im_gSendFile);
	iMethodFor(Socket, gTimedWrite, Socket_im_gTimedWrite);
	iMethodFor(Socket, gGetTotalBytesRead, Socket_im_gGetTotalBytesRead);
	iMethodFor(Socket, gIPAddress, Socket_im_gIPAddress);
	iMethodFor(Socket, gDispose, Socket_im_gDispose);
	iMethodFor(Socket, gIPAddressStr, Socket_im_gIPAddressStr);
	iMethodFor(Socket, gTimedReadMS, Socket_im_gTimedReadMS);
	iMethodFor(Socket, gWriteInt32, Socket_im_gWriteInt32);
	iMethodFor(Socket, gGCDispose, Socket_im_gDispose);
	iMethodFor(Socket, gReadInt32, Socket_im_gReadInt32);
	iMethodFor(Socket, gGetStr, Socket_im_gGetStr);
	iMethodFor(Socket, gDeepDispose, Socket_im_gDispose);
	iMethodFor(Socket, gRead, Socket_im_gRead);
	iMethodFor(Socket, gGetCipher, Socket_im_gGetCipher);
	iMethodFor(Socket, gGetPeerCertificateIssuerName, Socket_im_gGetPeerCertificateIssuerName);
	iMethodFor(Socket, gSendStr, Socket_im_gSendStr);

	Socket_cv = GetCVs(Socket);

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return Socket_c;
}




/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 32 "Socket.d"
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#define USE_FCNTL 
#endif 


#line 37 "Socket.d"
#ifdef _MSC_VER 
#if _MSC_VER > 1200 
#define _CRT_SECURE_NO_DEPRECATE 
#define _POSIX_ 
#endif 


#line 42 "Socket.d"
#endif 


#line 44 "Socket.d"
#include <stdio.h> 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
#include <winsock.h> 
#endif 


#line 48 "Socket.d"
#include <stdlib.h> 
#ifdef __WINE__ 
#else 


#line 51 "Socket.d"
#include <errno.h> 
#endif 


#line 53 "Socket.d"
#include <string.h> 
#include <ctype.h> 
#include <time.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#include <unistd.h> 
#include <netdb.h> 
#include <netinet/in.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <arpa/inet.h> 
#endif 


#line 67 "Socket.d"
#ifdef USE_FCNTL 
#include <fcntl.h> 
#endif 


#line 72 "Socket.d"
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#define closesocket close 
#define ioctlsocket ioctl 
#define SOCKET int 
#define INVALID_SOCKET -1 
#define SOCKET_ERROR -1 
#define WSAEINTR EINTR 
#define WSAEWOULDBLOCK EWOULDBLOCK 
#define TRUE 1 
#endif 


#line 84 "Socket.d"
#define BACKLOG 20 

#ifdef MY_SSL 
#include "ssleay.h" 

struct SSL_SOCKET { 
	short int flag; 
	union { 
		SSL* ssfd; 
		SOCKET sfd; 
	} SSL_union; 
}; 


typedef struct SSL_SOCKET G_SOCKET; 

#define CLIENT_VERIFY_OPTION SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT 




#define SSL_HANDSHAKE_MAX_WAIT 500 
#define MAX_OF_HANDSHAKES 2400 

#define CERTF "PEM\\PEM_CLI\\clicert.pem" 
#define KEYF "PEM\\PEM_CLI\\clikey.pem" 

#define CAfile "PEM\\PEM_CA\\cacert.pem" 
#define CApath ".\\PEM\\PEM_CA" 

#define SERVER_AUTH_CLIENT 0 



static int s_server_verify=SSL_VERIFY_NONE; 



#else 


#line 123 "Socket.d"
typedef SOCKET G_SOCKET; 

typedef int SSL_CTX; 
#endif 


#define	CLASS	Socket_c
#define	ivType	Socket_iv_t

#include "generics.h"

object	Socket_c;


#line 167 "Socket.c"
typedef struct  _Socket_iv_t  {
	G_SOCKET iFP;
	struct sockaddr_in iAddress;
	int iVerifyError;
	SSL_CTX * iCtx;
	char * iCipher;
	int iServerAuthClient;
	int iServerSSL;
	long iTotalBytesRead;
}	Socket_iv_t;


#line 180 "Socket.c"
typedef struct  _Socket_cv_t  {
	int cNumbInstances;
	int cError;
	char * cErrorStr;
}	Socket_cv_t;

static	Socket_cv_t	*Socket_cv;


#line 149 "Socket.d"
#ifdef MY_SSL 
static int init_Server_SSL_CTX(ivType *iv); 
static int SSL_Server_Handshake(ivType *iv, SSL* ssl); 
static int verify_callback(int ok, X509_STORE_CTX *ctx); 
static int verify_depth=1; 
static int verify_error=X509_V_OK; 
#endif 


#line 158 "Socket.d"
#define t_makeword(a, b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) << 8)) 
#define MAX_WAIT 120 
#define SMALLBUFLEN 256 
#define BUFLEN 2048 

typedef unsigned short int uint16_t; 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
typedef unsigned long int uint32_t; 
#endif 


#line 168 "Socket.d"
static int initSockets(void); 
static int is_ip_address(char *s); 
static int what_error(void); 
static void sleepInMilliSeconds(unsigned time); 

static int updateErrorStr(char * strBuf); 
static object decrementUsage(void); 
static int sufSSLConnect(ivType *iv, SOCKET sockfd, short int flag); 


#ifdef MY_SSL 
static int init_Client_SSL_CTX(ivType *iv); 
static int init_SSL(ivType *iv, SSL** pssl, SOCKET sockfd); 
static int SSL_Client_Handshake(ivType* iv, SSL* ssl); 
static int set_cert_stuff(SSL_CTX* ctx, char* cert_file, char* key_file); 
static int verify_Server(ivType* iv, SSL* ssl); 

static void print_stats(SSL_CTX* ssl_ctx); 
static void print_Server_Certificate(SSL* ssl); 

#endif 


#line 191 "Socket.d"
cmeth objrtn Socket_cm_gNew(object self)
{ 
	return gShouldNotImplement(self, "gNew"); 
} 

#line 203 "Socket.d"
static int initSockets() 
{ 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
	WORD wVersionRequested; 
	WSADATA wsaData; 
	int err; 
	char strBuf[SMALLBUFLEN]; 

	if (!Socket_cv->cNumbInstances) { 
		memset(&wsaData,0,sizeof(wsaData)); 
		wVersionRequested = t_makeword(1, 1); 

		if(WSAStartup(wVersionRequested, &wsaData)!=0) { 
			err=WSAGetLastError(); 

			Socket_cv->cError = 1; 
			sprintf(strBuf, "unable to start WINSOCK (cError) in initSockets(), error code=%d.",err); 
			updateErrorStr(strBuf); 
			return 0; 
		} 

#line 229 "Socket.d"
	} 
#endif 


#line 231 "Socket.d"
	return 1; 
} 




cmeth objrtn Socket_cm_gSocketConnect(object self, char *addr, int port, short int flag)
{ 
	return gProxyConnect(self, addr, port, flag, NULL, 0, NULL, NULL); 
} 
static object errorReturn(object obj, int e, char *msg) 
{ 
	Socket_cv->cError = e; 
	updateErrorStr(msg); 
	return gDispose(obj); 
} 

cmeth objrtn Socket_cm_gProxyConnect(object self, char *addr, int port, short int flag, char *proxy_addr, int proxy_port, char *proxy_user, char *proxy_pw)
{ 

	struct hostent *he = NULL; 
	struct sockaddr_in their_addr; 
	int isip, isproxy = !!proxy_addr; 
	SOCKET sockfd; 
	char strBuf[SMALLBUFLEN]; 
	object obj; 
	ivType *iv; 

	if (!Socket_cv->cNumbInstances && !initSockets()) 
		return NULL; 

	Socket_cv->cNumbInstances++; 

	isip = is_ip_address(addr); 

	if (!isip) 
		if ((he=gethostbyname(addr)) == NULL) { 
		Socket_cv->cError = 2; 
		sprintf(strBuf, "Invalid IP address (cError) in gSocketConnect."); 
		updateErrorStr(strBuf); 
		return decrementUsage(); 
	} 


	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) { 
		Socket_cv->cError = 3; 
		sprintf(strBuf, "INVALID_SOCKET (cError=3) in gSocketConnect."); 
		updateErrorStr(strBuf); 
		return decrementUsage(); 
	} 

	memset(&their_addr, 0, sizeof their_addr); 
	their_addr.sin_family = AF_INET; 
	their_addr.sin_port = htons((unsigned short) (isproxy ? proxy_port : port)); 
	if (isip || isproxy) 
		their_addr.sin_addr.s_addr = inet_addr(isproxy ? proxy_addr : addr); 
	else 
		their_addr.sin_addr = *((struct in_addr *)he->h_addr); 

	if (connect(sockfd, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == SOCKET_ERROR) { 
		Socket_cv->cError = 4; 
		sprintf(strBuf, "SOCKET_ERROR (cError=4) in gSocketConnect."); 
		updateErrorStr(strBuf); 
		closesocket(sockfd); 
		return decrementUsage(); 
	} 

#ifdef USE_FCNTL 
	{ 
		int flags = fcntl(sockfd, F_GETFL, 0); 
		if (flags < 0) { 
			Socket_cv->cError = 5; 
			sprintf(strBuf, "flags<0 (cError=5) in gSocketConnect."); 
			updateErrorStr(strBuf); 
			closesocket(sockfd); 
			return decrementUsage(); 
		} 

		flags |= O_NONBLOCK; 
		if (fcntl(sockfd, F_SETFL, flags) < 0) { 
			Socket_cv->cError = 6; 
			sprintf(strBuf, "flags<0 (cError=6) in gSocketConnect."); 
			updateErrorStr(strBuf); 
			closesocket(sockfd); 
			return decrementUsage(); 
		} 
	} 
#else 


#line 319 "Socket.d"
	{ 
		unsigned long flg = TRUE; 
		if (ioctlsocket(sockfd, FIONBIO, &flg) == SOCKET_ERROR) { 
			Socket_cv->cError = 7; 
			sprintf(strBuf, "SOCKET_ERROR (cError=7) in gSocketConnect."); 
			updateErrorStr(strBuf); 
			closesocket(sockfd); 
			return decrementUsage(); 
		} 
	} 
#endif 


#line 331 "Socket.d"
	obj = oSuper(Socket_c, gNew, self)(self); 
	iv = ivPtr(obj); 
	Socket_cv->cError = 0; 

	if (isproxy) { 
		unsigned char c, buf[81]; 
		int i = 0, r; 
		unsigned short dport = htons((unsigned short) port); 

#ifdef MY_SSL 
		iv->iFP.SSL_union.sfd = sockfd; 
#else 


#line 343 "Socket.d"
		iv->iFP = sockfd; 
#endif 


#line 346 "Socket.d"
		if (proxy_user) { 
#if 1 
			if (4 != gWrite(obj, "\x05\x02\x00\x02", 4)) 
				return errorReturn(obj, 8, "write error 1"); 
			if (2 != (r=gRead(obj, (char *)buf, 2))) 
				return errorReturn(obj, 8, "read error 1"); 
			if (buf[1] && buf[1] != 2) 
				return errorReturn(obj, 8, "Proxy authentication other than name/password required"); 
#else 


#line 355 "Socket.d"
			if (5 != gWrite(obj, "\x05\x03\x00\x01\x02", 5)) 
				return errorReturn(obj, 8, "write error 1"); 
			if (2 != (r=gRead(obj, (char *)buf, 2))) 
				return errorReturn(obj, 8, "read error 1"); 
			if (buf[1] && buf[1] != 2 && buf[1] != 1) 
				return errorReturn(obj, 8, "Proxy authentication other than GSSAPI and name/password required"); 
			if (buf[1] == 1) 
				return errorReturn(obj, 8, "Proxy authentication GSSAPI required"); 
#endif 


#line 364 "Socket.d"
			if (buf[1]) { 
				buf[0] = 1; 
				buf[1] = strlen(proxy_user); 
				strcpy(buf+2, proxy_user); 
				if (buf[1]+2 != gWrite(obj, buf, buf[1]+2)) 
					return errorReturn(obj, 8, "write error 7"); 
				buf[0] = proxy_pw ? strlen(proxy_pw) : 0; 
				if (proxy_pw) 
					strcpy(buf+1, proxy_pw); 
				if (buf[0]+1 != gWrite(obj, buf, buf[0]+1)) 
					return errorReturn(obj, 8, "write error 8"); 
				if (2 != (r=gRead(obj, (char *)buf, 2))) 
					return errorReturn(obj, 8, "read error 8"); 
				if (buf[1]) 
					return errorReturn(obj, 8, "Proxy username/password not accepted"); 
			} 
		} else { 
			if (3 != gWrite(obj, "\x05\x01\x00", 3)) 
				return errorReturn(obj, 8, "write error 1"); 
			if (2 != (r=gRead(obj, (char *)buf, 2))) 
				return errorReturn(obj, 8, "read error 1"); 
			if (buf[1]) 
				return errorReturn(obj, 8, "Proxy authentication required"); 
		} 

		if (3 != gWrite(obj, "\x05\x01\x00", 3)) 
			return errorReturn(obj, 8, "write error 2"); 
		if (isip) { 
			unsigned long ad = inet_addr(addr); 
			c = '\x01'; 
			if (1 != gWrite(obj, &c, 1)) 
				return errorReturn(obj, 8, "write error 3"); 
			if (4 != gWrite(obj, (char *) &ad, 4)) 
				return errorReturn(obj, 8, "write error 4"); 
		} else { 
			buf[0] = '\x03'; 
			strcpy(buf+2, addr); 
			buf[1] = strlen(buf+2); 
			if ((int) buf[1] + 2 != gWrite(obj, buf, (int) buf[1] + 2)) 
				return errorReturn(obj, 8, "write error 5"); 
		} 
		if (2 != gWrite(obj, (char *) &dport, 2)) 
			return errorReturn(obj, 8, "write error 6"); 
		if (4 != gRead(obj, buf, 4)) 
			return errorReturn(obj, 8, "read error 2"); 
		if (buf[1]) 
			return errorReturn(obj, 8, "general SOCKS server failure"); 
		if (buf[3] == 1) { 
			if (6 != gRead(obj, buf, 6)) 
				return errorReturn(obj, 8, "read error 3"); 
		} else if (buf[3] == 3) { 
			if (1 != gRead(obj, &c, 1)) 
				return errorReturn(obj, 8, "read error 4"); 
			if (c+2 != gRead(obj, buf, c+2)) 
				return errorReturn(obj, 8, "read error 5"); 
		} else if (buf[3] == 4) { 
			if (18 != gRead(obj, buf, 18)) 
				return errorReturn(obj, 8, "read error 6"); 
		} else 
			return errorReturn(obj, 8, "invalid ATYP"); 
	} 

	if (!sufSSLConnect(iv, sockfd, flag)) 
		return gDispose(obj); 

	return obj; 
} 

static int sufSSLConnect(ivType *iv, SOCKET sockfd, short int flag) 
{ 
#ifdef MY_SSL 
	iv->iVerifyError = X509_V_OK; 

	iv->iCipher = NULL; 
	iv->iCtx = NULL; 

	iv->iFP.flag = flag; 

	if (iv->iFP.flag == 0) 
		iv->iFP.SSL_union.sfd = sockfd; 
	else { 
		if (!init_Client_SSL_CTX(iv)) 
			return 0; 

		if (!init_SSL(iv, &iv->iFP.SSL_union.ssfd, sockfd)) 
			return 0; 

		if (!SSL_Client_Handshake(iv, iv->iFP.SSL_union.ssfd)) 
			return 0; 
	} 
#else 


#line 455 "Socket.d"
	iv->iFP = sockfd; 
#endif 


#line 457 "Socket.d"
	return 1; 
} 

imeth objrtn Socket_im_gDispose(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	SOCKET sockfd=0; 


#ifdef MY_SSL 
		if (iv->iFP.flag != 1) 
		sockfd = iv->iFP.SSL_union.sfd; 
	else { 
		if (iv->iFP.SSL_union.ssfd != NULL) { 
			sockfd = SSL_get_fd(iv->iFP.SSL_union.ssfd); 
			SSL_free(iv->iFP.SSL_union.ssfd); 
			iv->iFP.SSL_union.ssfd = NULL; 
		} 

		if (iv->iCtx) { 
			SSL_CTX_free(iv->iCtx); 
			iv->iCtx = NULL; 
		} 
	} 
	if (sockfd) 
		closesocket(sockfd); 
#else 

#line 483 "Socket.d"
		if (iv->iFP) 
		closesocket(iv->iFP); 
#endif 

#line 486 "Socket.d"
		decrementUsage(); 
	return oSuper(Socket_c, gDispose, self)(self); 
} 

imeth int Socket_im_gRead(object self, char *buf, unsigned n)
{ 
	return gTimedRead(self, buf, n, MAX_WAIT); 
} 

imeth int Socket_im_gTimedRead(object self, char *buf, unsigned n, int max_wait)
{ 
	return gTimedReadMS(self, buf, n, max_wait, 0L); 
} 

imeth int Socket_im_gTimedReadMS(object self, char *buf, unsigned n, int max_wait, long microsec_wait)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	unsigned tot = 0; 
	int t, e; 

	SOCKET sfd; 

#ifdef MY_SSL 
		SSL* ssl=NULL; 
	if(iv->iFP.flag==0) { 
		sfd=iv->iFP.SSL_union.sfd; 
	} 
	else { 
		ssl = iv->iFP.SSL_union.ssfd; 
		sfd=SSL_get_fd(ssl); 
	} 
#else 

#line 517 "Socket.d"
		sfd=iv->iFP; 
#endif 


#line 520 "Socket.d"
		while (n) { 
#ifdef MY_SSL 
			if (iv->iFP.flag) 
			t = SSL_read(ssl, buf, n); 
		else 
			t = recv(sfd, buf, n, 0); 
#else 

#line 527 "Socket.d"
			t = recv(sfd, buf, n, 0); 
#endif 


#line 530 "Socket.d"
			if (t < 0) 
			if ((e=what_error()) == WSAEINTR) 
			t = 0; 
		else if (e == WSAEWOULDBLOCK) { 
			fd_set setRead; 
			struct timeval timeout; 
			FD_ZERO(&setRead); 

			FD_SET(sfd, &setRead); 
			timeout.tv_sec = max_wait; 
			timeout.tv_usec = microsec_wait; 
			t = select(sfd+1, &setRead, NULL, NULL, &timeout); 
#line 547 "Socket.d"
			if (t <= 0) 
				return -1; 
			t = 0; 
		} else 
			return t; 
		else if (!t) 
			break; 
		tot += t; 
		buf += t; 
		n -= t; 
		iv->iTotalBytesRead += t; 
	} 
	return tot; 
} 



imeth int Socket_im_gWrite(object self, char *buf, unsigned n)
{ 
	return gTimedWrite(self, buf, n, MAX_WAIT); 
} 

imeth int Socket_im_gWriteInt32(object self, int val)
{ 
	uint32_t network_val; 

	network_val = htonl(val); 
	return gWrite(self, (char *)&network_val, sizeof(network_val)); 
} 

imeth int Socket_im_gReadInt32(object self, int *val)
{ 
	uint32_t network_val; 

	if (gRead(self, (char *)&network_val, sizeof(network_val)) != sizeof(network_val)) 
		return 0; 
	*val = ntohl(network_val); 
	return 1; 
} 


imeth int Socket_im_gTimedWrite(object self, char *buf, unsigned n, int max_wait)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	unsigned tot = 0; 
	int t, e; 
	SOCKET sfd; 

#ifdef MY_SSL 
		SSL* ssl=NULL; 
	if(iv->iFP.flag==0) { 
		sfd=iv->iFP.SSL_union.sfd; 
	} 
	else { 
		ssl = iv->iFP.SSL_union.ssfd; 
		sfd=SSL_get_fd(ssl); 
	} 
#else 

#line 604 "Socket.d"
		sfd = iv->iFP; 
#endif 


#line 607 "Socket.d"
		while (n) { 
#ifdef MY_SSL 
			if (iv->iFP.flag) 
			t = SSL_write(ssl, buf, n); 
		else 
			t = send(sfd, buf, n, 0); 
#else 

#line 614 "Socket.d"
			t = send(sfd, buf, n, 0); 
#endif 


#line 617 "Socket.d"
			if (t <= 0) 
			if ((e=what_error()) == WSAEINTR) 
			t = 0; 
		else if (e == WSAEWOULDBLOCK) { 
			fd_set setWrite; 
			struct timeval timeout; 
			FD_ZERO(&setWrite); 
			FD_SET(sfd, &setWrite); 
			timeout.tv_sec = max_wait; 
			timeout.tv_usec = 0; 
			t = select(sfd+1, NULL, &setWrite, NULL, &timeout); 
			if (t <= 0) 
				return -1; 
			t = 0; 
		} else 
			return t; 
		tot += t; 
		buf += t; 
		n -= t; 
	} 
	return tot; 
} 


cmeth int Socket_cm_gGetErrorCode(object self)
{ 
	return Socket_cv->cError; 
} 


cmeth char * Socket_cm_gGetErrorStr(object self)
{ 
	return Socket_cv->cErrorStr; 
} 

#line 657 "Socket.d"
static int is_ip_address(char *s) 
{ 
	int dots = 0; 

	for ( ; *s ; s++) 
		if (*s == '.') 
		dots++; 
	else if (!isdigit(*s)) 
		return 0; 
	return dots == 3; 
} 



#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
#define MODE "" 
#else 


#line 674 "Socket.d"
#define MODE "b" 
#endif 


#line 677 "Socket.d"
extern unsigned long BufCRC(unsigned long crc, char *buf, int size); 
extern unsigned long InitCRC(void); 

#define SEND(x) if (sizeof(x) != gWrite(self, (char *) &x, sizeof(x))) goto er1 
#define RECV(x) if (sizeof(x) != gRead(self, (char *) &x, sizeof(x))) goto er1 

#line 688 "Socket.d"
imeth int Socket_im_gSendStr(object self, char *str)
{ 
	char buf[80]; 
	strcpy(buf, str); 
	return 80!=gWrite(self, buf, sizeof(buf)); 
} 


#line 701 "Socket.d"
imeth int Socket_im_gSendFile(object self, char *fromFile, char *toFile)
{ 
	FILE *fp = fopen(fromFile, "r" MODE); 
	uint32_t size, crc, crc2; 
	struct stat sb; 
	int len; 
	uint16_t nlen, code = htons(1); 
	char buf[BUFLEN]; 

	if (!fp) 
		return 1; 
	if (fstat(fileno(fp), &sb)) 
		goto er1; 
	size = htonl(sb.st_size); 
	crc = InitCRC(); 

	fseek(fp, 0L, SEEK_SET); 
	SEND(code); 
	SEND(size); 

	if (!toFile) 
		toFile = fromFile; 
	len = strlen(toFile) + 1; 
	nlen = htons((short)len); 
	SEND(nlen); 
	if (len != gWrite(self, toFile, len)) 
		goto er1; 

	while ((len = fread(buf, 1, BUFLEN, fp)) > 0) 
		if (len != gWrite(self, buf, len)) 
		goto er1; 
	else 
		crc = BufCRC(crc, buf, len); 
	if (ferror(fp)) 
		goto er1; 
	crc = htonl(crc); 
	SEND(crc); 
	RECV(crc2); 
	if (crc != crc2) 
		goto er1; 
	fclose(fp); 
	return 0; 
	er1: 
	fclose(fp); 
	return -1; 
} 


#line 753 "Socket.d"
imeth int Socket_im_gGetStr(object self, char *str)
{ 
	char buf[80]; 
	int r = gRead(self, buf, 80); 
	if (r != 80) 
		return 1; 
	buf[79] = '\0'; 
	strcpy(str, buf); 
	return 0; 
} 


#line 771 "Socket.d"
imeth int Socket_im_gRecvFile(object self, char *toFile)
{ 
	FILE *fp = fopen(toFile, "w" MODE); 
	uint32_t size, crc, crc2; 
	int len; 
	uint16_t nlen, code; 
	char buf[BUFLEN]; 

	if (!fp) 
		return 1; 
	crc = InitCRC(); 

	RECV(code); 
	if (code != htons(1)) 
		goto er1; 

	RECV(size); 
	size = ntohl(size); 

	RECV(nlen); 
	len = ntohs(nlen); 
	if (len && len != gRead(self, buf, len)) 
		goto er1; 

	while (size) { 
		unsigned rlen; 

		rlen = size > BUFLEN ? BUFLEN : size; 
		len = gRead(self, buf, rlen); 
		if (len < 0) 
			goto er1; 
		crc = BufCRC(crc, buf, len); 
		if (len != fwrite(buf, 1, len, fp)) 
			goto er1; 
		size -= len; 
	} 

	crc = htonl(crc); 
	RECV(crc2); 
	SEND(crc); 
	if (crc != crc2) 
		goto er1; 
	fclose(fp); 
	return 0; 
	er1: 
	fclose(fp); 
	unlink(toFile); 
	return -1; 
} 

imeth long Socket_im_gGetTotalBytesRead(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	return iv->iTotalBytesRead; 
} 

static object decrementUsage() 
{ 
	if (Socket_cv->cNumbInstances && !--Socket_cv->cNumbInstances) 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
	WSACancelBlockingCall(), 
		WSACleanup() 
#endif 


#line 833 "Socket.d"
	; 
	return NULL; 
} 


static int what_error() 
{ 
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
	return errno; 
#else 


#line 843 "Socket.d"
	return WSAGetLastError(); 
#endif 


#line 845 "Socket.d"
} 



static int updateErrorStr(char * strBuf) 
{ 
	if (Socket_cv->cErrorStr) { 
		free(Socket_cv->cErrorStr); 
		Socket_cv->cErrorStr = NULL; 
	} 

	Socket_cv->cErrorStr = (char *)malloc(strlen(strBuf)+1); 
	if (Socket_cv->cErrorStr) { 
		strcpy(Socket_cv->cErrorStr, strBuf); 
		return 1; 
	} else { 
		Socket_cv->cError = -9999; 
		return 0; 
	} 
} 

#line 872 "Socket.d"
static void sleepInMilliSeconds(unsigned time) 
{ 
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
	struct timeval tval; 
	tval.tv_sec = time/1000; 
	tval.tv_usec = time%1000; 
	select(0, NULL, NULL, NULL, &tval); 

#else 


#line 881 "Socket.d"
	Sleep(time); 
#endif 


#line 883 "Socket.d"
} 



imeth char * Socket_im_gGetPeerCertificateIssuerName(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char* retStr=NULL; 
	char buf[SMALLBUFLEN]; 
#ifdef MY_SSL 
		X509 *peer=NULL; 
	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		retStr = (char *)malloc(strlen(buf)+1); 
		strcpy(retStr, buf); 
	} 
	else{ 
		peer=SSL_get_peer_certificate(iv->iFP.SSL_union.ssfd); 

		if (peer != NULL) { 
			X509_NAME_oneline(X509_get_issuer_name(peer),buf,SMALLBUFLEN); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr,buf); 
			X509_free(peer); 

		} 
		else { 
			strcpy(buf,"No peer certificate"); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
	} 
#else 

#line 915 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	retStr = (char *)malloc(strlen(buf)+1); 
	strcpy(retStr, buf); 
#endif 

#line 919 "Socket.d"
		return retStr; 
} 



imeth char * Socket_im_gGetPeerCertificateSubjectName(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char* retStr=NULL; 
	char buf[SMALLBUFLEN]; 

#ifdef MY_SSL 
		X509 *peer=NULL; 
	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		retStr = (char *)malloc(strlen(buf)+1); 
		strcpy(retStr, buf); 
	} 
	else{ 
		peer=SSL_get_peer_certificate(iv->iFP.SSL_union.ssfd); 

		if (peer != NULL) { 
			X509_NAME_oneline(X509_get_subject_name(peer),buf,SMALLBUFLEN); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr,buf); 
			X509_free(peer); 
		} 
		else { 
			strcpy(buf, "No peer certificate"); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
	} 
#else 

#line 952 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	retStr = (char *)malloc(strlen(buf)+1); 
	strcpy(retStr, buf); 
#endif 

#line 956 "Socket.d"
		return retStr; 
} 



imeth int Socket_im_gHowManyBitsOfPeerPublicKey(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#ifdef MY_SSL 
		X509* peer=NULL; 
	int i; 
	if(iv->iFP.flag == 0) { 
		return -1; 
	} 
	else{ 
		peer=SSL_get_peer_certificate(iv->iFP.SSL_union.ssfd); 
		if (peer != NULL) { 
			i = EVP_PKEY_bits(X509_get_pubkey(peer)); 
			X509_free(peer); 
			return i; 
		} 
		else { 
			return -1; 
		} 
	} 
#else 

#line 981 "Socket.d"
		return -1; 
#endif 

#line 983 "Socket.d"
	} 



imeth char * Socket_im_gGetCipher(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char* retStr=NULL; 
	char buf[SMALLBUFLEN]; 
#ifdef MY_SSL 
		SSL_CIPHER* c; 
	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		retStr = (char *)malloc(strlen(buf)+1); 
		strcpy(retStr, buf); 
	} 
	else{ 
		c=SSL_get_current_cipher(iv->iFP.SSL_union.ssfd); 
		if (c != NULL) { 
			strcpy(buf, SSL_CIPHER_get_version(c)); 
			strcat(buf, ": "); 
			strcat(buf, SSL_CIPHER_get_name(c)); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
		else { 
			strcpy(buf,"No peer certificate"); 
			retStr = (char *)malloc(strlen(buf)+1); 
			strcpy(retStr, buf); 
		} 
	} 
#else 

#line 1014 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	retStr = (char *)malloc(strlen(buf)+1); 
	strcpy(retStr, buf); 
#endif 

#line 1018 "Socket.d"
		return retStr; 
} 



imeth objrtn Socket_im_gGetSessionInfo(object self, char **session1, char **session2, char **session3)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	char buf[SMALLBUFLEN]; 


#ifdef MY_SSL 
		int i; 
	char str[128],*s; 
	SSL_SESSION *x; 

	if(iv->iFP.flag == 0) { 
		strcpy(buf, "SSL flag off"); 
		*session1 = (char *)malloc(strlen(buf)+1); 
		strcpy(*session1, buf); 
		*session2 = NULL; 
		*session3 = NULL; 
	} 
	else { 
		x = SSL_get_session(iv->iFP.SSL_union.ssfd); 

		if (x != NULL) { 


			if (x->ssl_version == SSL2_VERSION) 
				s="SSLv2"; 
			else if (x->ssl_version == SSL3_VERSION) 
				s="SSLv3"; 
			else if (x->ssl_version == TLS1_VERSION) 
				s="TLSv1"; 
			else 
				s="unknown"; 
			sprintf(str, "    Protocol:      %s\n", s); 
			strcpy(buf, str); 

			sprintf(str,"    Cipher:         %s\n",(x->cipher == NULL)?"unknown":x->cipher->name); 
			strcat(buf, str); 

			strcat(buf,"    Session-ID:  "); 
			for (i=0; i<(int)x->session_id_length; i++){ 
				sprintf(str,"%02X",x->session_id[i]); 
				strcat(buf, str); 
			} 
			strcat(buf,"\n"); 

			*session1 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session1, buf); 



			strcpy(buf,"    Master-Key: "); 
			for (i=0; i<(int)x->master_key_length; i++) { 
				sprintf(str,"%02X",x->master_key[i]); 
				strcat(buf, str); 
			} 
			strcat(buf,"\n"); 

			*session2 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session2, buf); 



			strcpy(buf, "    Key-Arg:       "); 
			if (x->key_arg_length == 0) 
				strcat(buf,"None"); 
			else { 
				for (i=0; i<(int)x->key_arg_length; i++) { 
					sprintf(str,"%02X",x->key_arg[i]); 
					strcat(buf,str); 
				} 
			} 

			strcat(buf, "\n"); 

			if (x->time != 0L){ 
				struct tm * tmTime; 
				char timeStr[30]; 
				tmTime = localtime((time_t*)&(x->time)); 
				strcpy(timeStr, asctime(tmTime)); 
				timeStr[24]=' '; 
				timeStr[25] = 0; 
				sprintf(str,"    Start Time:   %s", timeStr); 
				strcat(buf,str); 
			} 
			strcat(buf, "\n"); 

			if (x->timeout != 0L){ 
				sprintf(str,"    Timeout:      %d (Sec)", x->timeout); 
				strcat(buf, str); 
			} 

			*session3 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session3, buf); 
		} 
		else { 
			strcpy(buf, "Session error"); 
			*session1 = (char *)malloc(strlen(buf)+1); 
			strcpy(*session1, buf); 
			*session2 = NULL; 
			*session3 = NULL; 
		} 
	} 
#else 

#line 1125 "Socket.d"
		strcpy(buf, "MY_SSL not defined"); 
	*session1 = (char *)malloc(strlen(buf)+1); 
	strcpy(*session1, buf); 
	*session2 = NULL; 
	*session3 = NULL; 
#endif 

#line 1131 "Socket.d"
		return self; 
} 

#line 1138 "Socket.d"
static SOCKET makeServer(int port) 
{ 
	struct sockaddr_in serv_addr; 
	SOCKET listen_sd; 


	if (!Socket_cv->cNumbInstances && !initSockets()) 
		return -1; 

	Socket_cv->cNumbInstances++; 

	if ((listen_sd = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
		return -1; 
	memset(&serv_addr, 0, sizeof(serv_addr)); 
	serv_addr.sin_family = AF_INET; 
	serv_addr.sin_port = htons((unsigned short) port); 
	serv_addr.sin_addr.s_addr = INADDR_ANY; 
	if (bind(listen_sd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr)) == SOCKET_ERROR) { 
		closesocket(listen_sd); 
		return -1; 
	} 
	if (listen(listen_sd, BACKLOG) == SOCKET_ERROR) { 
		closesocket(listen_sd); 
		return -1; 
	} 
	return listen_sd; 
} 

#line 1170 "Socket.d"
cmeth objrtn Socket_cm_gMakeServer(object self, int port, int ssl)
{ 
	object obj = oSuper(Socket_c, gNew, self)(self); 
	ivType *iv = ivPtr(obj); 

#ifdef MY_SSL 
	if (iv->iFP.flag = ssl) { 
		iv->iServerSSL = ssl; 
		if (-1 == init_Server_SSL_CTX(iv)) 
			return NULL; 
	} 
	iv->iFP.SSL_union.sfd = makeServer(port); 
#else 


#line 1183 "Socket.d"
	iv->iFP = makeServer(port); 
#endif 


#line 1185 "Socket.d"
	return obj; 
} 


PMETHOD objrtn newSock(object self, SOCKET newsock, int flag, int ssl, struct sockaddr_in *addr)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#ifdef MY_SSL 
		iv->iFP.flag = flag; 
	iv->iFP.SSL_union.sfd = newsock; 
	iv->iServerSSL = ssl; 
#else 

#line 1196 "Socket.d"
		iv->iFP = newsock; 
#endif 

#line 1198 "Socket.d"
		iv->iAddress = *addr; 
	++Socket_cv->cNumbInstances; 
	return self; 
} 

imeth unsigned long Socket_im_gIPAddress(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	return iv->iAddress.sin_addr.s_addr; 
} 

imeth char * Socket_im_gIPAddressStr(object self, char *buf)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#if (defined(unix) || defined(__APPLE__) || defined(__minix)) && !defined(__WINE__) 
		char *addr = inet_ntoa(iv->iAddress.sin_addr); 
	strcpy(buf, addr); 
#else 

#line 1214 "Socket.d"
		sprintf(buf, "%d.%d.%d.%d", 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b1, 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b2, 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b3, 
		(int) iv->iAddress.sin_addr.S_un.S_un_b.s_b4); 
#endif 

#line 1220 "Socket.d"
		return buf; 
} 





imeth objrtn Socket_im_gAccept(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
	struct sockaddr_in client_addr; 
	int sin_size = sizeof(struct sockaddr_in); 
	SOCKET newsock; 
#ifdef MY_SSL 
		SOCKET sockfd = iv->iFP.SSL_union.sfd; 
	int flag = iv->iFP.flag; 
#else 

#line 1236 "Socket.d"
		SOCKET sockfd = iv->iFP; 
	int flag = 0; 
#endif 


#line 1240 "Socket.d"
		newsock = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size); 
	if (newsock == INVALID_SOCKET) { 
#if (!defined(unix) && !defined(__APPLE__) && !defined(__minix)) || defined(__WINE__) 
			int e = WSAGetLastError(); 
#endif 

#line 1245 "Socket.d"
			return NULL; 
	} 
#ifdef USE_FCNTL 
	{ 
		int flags = fcntl(newsock, F_GETFL, 0); 

		if (flags < 0) { 
			closesocket(newsock); 
			return NULL; 
		} 


		flags |= O_NONBLOCK; 
		if (fcntl(newsock, F_SETFL, flags) < 0) { 
			closesocket(newsock); 
			return NULL; 
		} 
	} 
#else 

#line 1264 "Socket.d"
	{ 
		unsigned long flg = TRUE; 
		if (ioctlsocket(newsock, FIONBIO, &flg) == SOCKET_ERROR) { 
			closesocket(newsock); 
			return NULL; 
		} 
	} 
#endif 




#line 1275 "Socket.d"
		return newSock(oSuper(Socket_c, gNew, CLASS)(CLASS), newsock, flag, iv->iServerSSL, &client_addr); 
} 

imeth objrtn Socket_im_gServerSocketConnect(object self)
{ Socket_iv_t *iv = GetIVs(Socket, self);
#ifdef MY_SSL 
		int tmp; 
	SOCKET sockfd; 
	G_SOCKET gs; 
	SSL* ssl = NULL; 

	if (iv->iServerSSL) { 
		gs.flag = iv->iServerSSL; 
		tmp = init_SSL(iv, &ssl, iv->iFP.SSL_union.sfd); 
		if (tmp == -1) 
			return NULL; 
		tmp = SSL_Server_Handshake(iv, ssl); 
		if (tmp == -1) 
			return NULL; 
		gs.SSL_union.ssfd = ssl; 
		iv->iFP = gs; 
	} 
#endif 

#line 1298 "Socket.d"
		return self; 
} 



#ifdef MY_SSL 

static int init_SSL(ivType *iv, SSL** pssl, SOCKET sockfd) 
{ 
	char strBuf[SMALLBUFLEN]; 
	*pssl = (SSL *)SSL_new(iv->iCtx); 


	if(*pssl == NULL) { 
		Socket_cv->cError = 11; 
		sprintf(strBuf, "init_Client_SSL: ssl=NULL (cError=11) in init_SSL"); 
		updateErrorStr(strBuf); 
		return 0; 
	} 

	SSL_set_fd(*pssl, sockfd); 
	SSL_set_connect_state(*pssl); 
	return 1; 
} 

static int set_cert_stuff(SSL_CTX* ctx, char* cert_file, char* key_file) 
{ 
	char strBuf[SMALLBUFLEN]; 
	if (cert_file != NULL) 
	{ 
		if (SSL_CTX_use_certificate_file(ctx,cert_file, SSL_FILETYPE_PEM) <= 0) 
		{ 
			Socket_cv->cError = 14; 
			sprintf(strBuf, "unable to get certificate from '%s' (cError=14) in set_cert_stuff", cert_file); 
			updateErrorStr(strBuf); 
			return 0; 
		} 

		if (key_file == NULL) key_file=cert_file; 
		if (SSL_CTX_use_PrivateKey_file(ctx,key_file, SSL_FILETYPE_PEM) <= 0) 
		{ 
			Socket_cv->cError = 15; 
			sprintf(strBuf, "unable to get private key from '%s' (cError=15) in set_cert_stuff", key_file); 
			updateErrorStr(strBuf); 
			return 0; 
		} 



		if (!SSL_CTX_check_private_key(ctx)) 
		{ 
			Socket_cv->cError = 16; 
			sprintf(strBuf, "Private key does not match the certificate public key (cError=16) in set_cert_stuff"); 
			updateErrorStr(strBuf); 
			return 0; 
		} 
	} 
	return 1; 
} 



static int verify_Server(ivType* iv, SSL* ssl) 
{ 
	char strBuf[SMALLBUFLEN]; 

	iv->iVerifyError=SSL_get_verify_result(ssl); 

	switch (iv->iVerifyError) 
	{ 
		case X509_V_OK: 
		return 1; 
		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: 
		Socket_cv->cError = 17; 
		sprintf(strBuf, "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT (cError=17) in verify_Server"); 


		break; 
		case X509_V_ERR_CERT_NOT_YET_VALID: 
		Socket_cv->cError = 18; 
		sprintf(strBuf, "X509_V_ERR_CERT_NOT_YET_VALID (cError=18) in verify_Server"); 
		break; 
		case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: 
		Socket_cv->cError = 19; 
		sprintf(strBuf, "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD (cError=19) in verify_Server"); 


		break; 
		case X509_V_ERR_CERT_HAS_EXPIRED: 
		Socket_cv->cError = 20; 
		sprintf(strBuf, "X509_V_ERR_CERT_HAS_EXPIRED (cError=20) in verify_Server"); 
		break; 
		case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: 
		Socket_cv->cError = 21; 
		sprintf(strBuf, "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD (cError=21) in verify_Server"); 


		break; 
		default: 
		Socket_cv->cError = 22; 
		sprintf(strBuf, "verify server error (cError=22) in verify_Server"); 
	} 

	updateErrorStr(strBuf); 
	return 0; 
} 

#line 1472 "Socket.d"
static void print_stats(SSL_CTX* ssl_ctx) 
{ 
	printf("%4ld items in the session cache\n", SSL_CTX_sess_number(ssl_ctx)); 
	printf("%4d client connects (SSL_connect())\n", SSL_CTX_sess_connect(ssl_ctx)); 
	printf("%4d client renegotiates (SSL_connect())\n", SSL_CTX_sess_connect_renegotiate(ssl_ctx)); 
	printf("%4d client connects that finished\n", SSL_CTX_sess_connect_good(ssl_ctx)); 
	printf("%4d server accepts (SSL_accept())\n", SSL_CTX_sess_accept(ssl_ctx)); 
	printf("%4d server renegotiates (SSL_accept())\n", SSL_CTX_sess_accept_renegotiate(ssl_ctx)); 
	printf("%4d server accepts that finished\n", SSL_CTX_sess_accept_good(ssl_ctx)); 
	printf("%4d session cache hits\n",SSL_CTX_sess_hits(ssl_ctx)); 
	printf("%4d session cache misses\n",SSL_CTX_sess_misses(ssl_ctx)); 
	printf("%4d session cache timeouts\n",SSL_CTX_sess_timeouts(ssl_ctx)); 
	printf("%4d callback cache hits\n",SSL_CTX_sess_cb_hits(ssl_ctx)); 
	printf("%4d cache full overflows (%d allowed)\n", SSL_CTX_sess_cache_full(ssl_ctx), 
		SSL_CTX_sess_get_cache_size(ssl_ctx)); 
} 



static int init_Client_SSL_CTX(ivType *iv) 
{ 
	int off = 0; 
	SSL_METHOD* meth = NULL; 
	char strBuf[SMALLBUFLEN]; 

	meth = SSLv2_client_method(); 


	SSLeay_add_ssl_algorithms(); 
	SSL_load_error_strings(); 

	iv->iCtx = SSL_CTX_new (meth); 
	if(!iv->iCtx) { 
		Socket_cv->cError = 8; 
		sprintf(strBuf, "iCtx=NULL (cError=8) in init_Client_SSL_CTX."); 
		updateErrorStr(strBuf); 
		return 0; 
	} 

#line 1515 "Socket.d"
	SSL_CTX_set_options(iv->iCtx, SSL_OP_ALL|off); 



	if(SERVER_AUTH_CLIENT) { 
		if (!set_cert_stuff(iv->iCtx, CERTF, KEYF)) { 
			Socket_cv->cError = 9; 
			sprintf(strBuf, "Client certificate and key not matched (cError=9) in init_Client_SSL_CTX.\n"); 
			strcat(strBuf, Socket_cv->cErrorStr); 
			updateErrorStr(strBuf); 
			return 0; 
		} 
	} 

	if (iv->iCipher != NULL) 
		SSL_CTX_set_cipher_list(iv->iCtx, iv->iCipher); 
	else 
		iv->iCipher=getenv("SSL_CIPHER"); 

	if (!SSL_CTX_load_verify_locations(iv->iCtx,CAfile,CApath)) 
	{ 
		Socket_cv->cError = 10; 
		sprintf(strBuf, "Load CA certificate error (cError=10) in init_Client_SSL_CTX."); 
		updateErrorStr(strBuf); 
		return 0; 
	} 



	return 1; 
} 



static int SSL_Client_Handshake(ivType* iv, SSL* ssl) 
{ 
	unsigned long int tmp; 
	char strBuf[SMALLBUFLEN]; 
	int t1; 




	tmp=0; 

	while(SSL_in_init(ssl)) 
	{ 

		if(tmp++ > MAX_OF_HANDSHAKES) { 
			Socket_cv->cError = 12; 
			sprintf(strBuf, "SSL hadshake fails (cError=12): ssl in state %d %s", 
				tmp, SSL_state_string_long(ssl)); 
			updateErrorStr(strBuf); 
			return 0; 
		} 


		SSL_connect(ssl); 

		sleepInMilliSeconds(SSL_HANDSHAKE_MAX_WAIT); 
	} 




	if( !verify_Server(iv, ssl) ) 
		return 0; 

	return 1; 
} 

#line 1593 "Socket.d"
static void print_Server_Certificate(SSL* ssl) 
{ 
	char buf[BUFLEN]; 
	X509* server_cert; 


	printf ("SSL connection using %s\n", SSL_get_cipher (ssl)); 



	server_cert = SSL_get_peer_certificate (ssl); 

	if (server_cert != NULL) { 
		printf ("Server certificate:\n"); 

		X509_NAME_oneline (X509_get_subject_name (server_cert), buf, BUFLEN); 
		printf ("\t subject: %s\n", buf); 

		X509_NAME_oneline (X509_get_issuer_name (server_cert), buf, BUFLEN); 
		printf ("\t issuer: %s\n", buf); 




		X509_free (server_cert); 
	} else 
		printf ("Server does not have certificate.\n"); 
} 

static int init_Server_SSL_CTX(ivType *iv) 
{ 
	int off=0; 

	SSL_METHOD* meth=NULL; 


	SSL_load_error_strings(); 
	SSLeay_add_ssl_algorithms(); 

	meth = SSLv2_method(); 

#line 1638 "Socket.d"
	off|=SSL_OP_NO_SSLv2; 
	off|=SSL_OP_NO_TLSv1; 

	iv->iCtx = SSL_CTX_new (meth); 
	if (iv->iCtx == NULL) 
	{ 

		return -1; 
	} 

	SSL_CTX_set_quiet_shutdown(iv->iCtx,1); 
	SSL_CTX_set_options(iv->iCtx, off); 
	SSL_CTX_sess_set_cache_size(iv->iCtx, 128); 

	if (!set_cert_stuff(iv->iCtx, CERTF, KEYF)) 
		return (-1); 


	if (iv->iCipher != NULL) 
		SSL_CTX_set_cipher_list(iv->iCtx, iv->iCipher); 




	if(iv->iServerAuthClient) { 
		if (!SSL_CTX_load_verify_locations(iv->iCtx,CAfile,CApath)) 
		{ 

			return -1; 
		} 
	} 

#line 1675 "Socket.d"
	if(iv->iServerAuthClient) { 
		SSL_CTX_set_verify(iv->iCtx,s_server_verify,verify_callback); 
		SSL_CTX_set_client_CA_list(iv->iCtx, SSL_load_client_CA_file(CAfile)); 
	} 

	return 0; 
} 

static int SSL_Server_Handshake(ivType *iv, SSL* ssl) 
{ 
	unsigned int tmp; 

#line 1692 "Socket.d"
	tmp=0; 

	while(SSL_in_init(ssl)) 
	{ 

		if(tmp++ > MAX_OF_HANDSHAKES) { 
			printf("\nSSL hadshake fails\n"); 
			printf("ssl state %d: %s\n", tmp, SSL_state_string_long(ssl)); 
			return -1; 
		} 

		SSL_accept(ssl); 

		sleepInMilliSeconds(SSL_HANDSHAKE_MAX_WAIT); 
	} 



	if (iv->iServerAuthClient) { 
		verify_error=SSL_get_verify_result(ssl); 

		if (verify_error != X509_V_OK) 
		{ 


			return (-1); 
		} 


	} 

	return 0; 
} 

#line 1732 "Socket.d"
#if 0 
static void print_Client_Certificate(SSL* ssl) 
{ 
	char buf[SMALL_BUF_LEN]; 
	X509* client_cert; 

	printf ("SSL connection using %s\n", SSL_get_cipher (ssl)); 



	client_cert = SSL_get_peer_certificate (ssl); 
	if (client_cert != NULL) { 
		printf ("Client certificate:\n"); 

		X509_NAME_oneline (X509_get_subject_name (client_cert), buf, SMALL_BUF_LEN); 
		printf ("\t subject: %s\n", buf); 

		X509_NAME_oneline (X509_get_issuer_name (client_cert), buf, SMALL_BUF_LEN); 
		printf ("\t issuer: %s\n", buf); 




		X509_free (client_cert); 
	} else 
		printf ("Client does not have certificate.\n"); 
} 
#endif 


#line 1761 "Socket.d"
static int verify_callback(int ok, X509_STORE_CTX *ctx) 
{ 
	char buf[256]; 
	X509 *err_cert; 
	int err,depth; 

	err_cert=X509_STORE_CTX_get_current_cert(ctx); 
	err= X509_STORE_CTX_get_error(ctx); 
	depth= X509_STORE_CTX_get_error_depth(ctx); 

	X509_NAME_oneline(X509_get_subject_name(err_cert),buf,256); 

	if (!ok) 
	{ 


		if (verify_depth >= depth) 
		{ 
			ok=1; 
			verify_error=X509_V_OK; 
		} 
		else 
		{ 
			ok=0; 
			verify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG; 
		} 
	} 
	switch (ctx->error) 
	{ 
		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: 
		X509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256); 

		break; 
		case X509_V_ERR_CERT_NOT_YET_VALID: 
		case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: 


		printf("X509_V_ERR_CERT_NOT_YET_VALID\n"); 
		break; 
		case X509_V_ERR_CERT_HAS_EXPIRED: 
		case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: 


		printf("X509_V_ERR_CERT_HAS_EXPIRED\n"); 
		break; 
	} 

	return(ok); 
} 

#endif 


#line 1837 "Socket.c"

objrtn	Socket_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (Socket_c) {
		LEAVECRITICALSECTION(cs);
		return Socket_c;
	}
	INHIBIT_THREADER;
	Stream_initialize();
	if (Socket_c)  {
		ENABLE_THREADER;
		LEAVECRITICALSECTION(cs);
		return Socket_c;
	}
	Socket_c = gNewClass(Class, "Socket", sizeof(Socket_iv_t), sizeof(Socket_cv_t), Stream, END);
	cMethodFor(Socket, gGetErrorCode, Socket_cm_gGetErrorCode);
	cMethodFor(Socket, gProxyConnect, Socket_cm_gProxyConnect);
	cMethodFor(Socket, gNew, Socket_cm_gNew);
	cMethodFor(Socket, gGetErrorStr, Socket_cm_gGetErrorStr);
	cMethodFor(Socket, gSocketConnect, Socket_cm_gSocketConnect);
	cMethodFor(Socket, gMakeServer, Socket_cm_gMakeServer);
	iMethodFor(Socket, gServerSocketConnect, Socket_im_gServerSocketConnect);
	iMethodFor(Socket, gTimedRead, Socket_im_gTimedRead);
	iMethodFor(Socket, gWrite, Socket_im_gWrite);
	iMethodFor(Socket, gGetSessionInfo, Socket_im_gGetSessionInfo);
	iMethodFor(Socket, gRecvFile, Socket_im_gRecvFile);
	iMethodFor(Socket, gAccept, Socket_im_gAccept);
	iMethodFor(Socket, gGetPeerCertificateSubjectName, Socket_im_gGetPeerCertificateSubjectName);
	iMethodFor(Socket, gHowManyBitsOfPeerPublicKey, Socket_im_gHowManyBitsOfPeerPublicKey);
	iMethodFor(Socket, gSendFile, Socket_im_gSendFile);
	iMethodFor(Socket, gTimedWrite, Socket_im_gTimedWrite);
	iMethodFor(Socket, gGetTotalBytesRead, Socket_im_gGetTotalBytesRead);
	iMethodFor(Socket, gIPAddress, Socket_im_gIPAddress);
	iMethodFor(Socket, gDispose, Socket_im_gDispose);
	iMethodFor(Socket, gIPAddressStr, Socket_im_gIPAddressStr);
	iMethodFor(Socket, gTimedReadMS, Socket_im_gTimedReadMS);
	iMethodFor(Socket, gWriteInt32, Socket_im_gWriteInt32);
	iMethodFor(Socket, gGCDispose, Socket_im_gDispose);
	iMethodFor(Socket, gReadInt32, Socket_im_gReadInt32);
	iMethodFor(Socket, gGetStr, Socket_im_gGetStr);
	iMethodFor(Socket, gDeepDispose, Socket_im_gDispose);
	iMethodFor(Socket, gRead, Socket_im_gRead);
	iMethodFor(Socket, gGetCipher, Socket_im_gGetCipher);
	iMethodFor(Socket, gGetPeerCertificateIssuerName, Socket_im_gGetPeerCertificateIssuerName);
	iMethodFor(Socket, gSendStr, Socket_im_gSendStr);

	Socket_cv = GetCVs(Socket);

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return Socket_c;
}




/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0



#line 2 "HttpRequest.d"
#include <stdlib.h> 
#include <ctype.h> 
#include <string.h> 
#include <curl/curl.h> 

#define INTERNET_OPTION_CLIENT_CERT_CONTEXT 84 

#define	CLASS	HttpRequest_c
#define	ivType	HttpRequest_iv_t

#include "generics.h"

object	HttpRequest_c;


#line 55 "HttpRequest.c"
typedef struct  _HttpRequest_iv_t  {
	object iUrl;
	char * iResponseStr;
	object iHeaders;
	object iContent;
	object iVerb;
	object iUser;
	object iPass;
	object iOutputFileName;
	object iErrorMessage;
	object iResponseHeaders;
	int iSecure;
	int iTimeoutSeconds;
	void * iCertificate;
	object iInternetOpenOptions;
}	HttpRequest_iv_t;


#line 74 "HttpRequest.c"
typedef struct  _HttpRequest_cv_t  {
	object cLogger;
}	HttpRequest_cv_t;

static	HttpRequest_cv_t	*HttpRequest_cv;



#line 32 "HttpRequest.d"
PMETHOD objrtn initInstance(object self, char *url, char *verb); 
PMETHOD int restCall(object self); 

static char *strlwr(char *p); 
static int my_trace(CURL *handle, curl_infotype type, char *data, size_t size, void *userp); 

struct data { 
	char trace_ascii; 
}; 


cmeth objrtn HttpRequest_cm_gNewHttpRequest(object self, char *url, char *verb)
{ 
	if (!url || !verb) 
		return NULL; 
	return initInstance(oSuper(HttpRequest_c, gNew, self)(self), url, verb); 
} 

cmeth objrtn HttpRequest_cm_gSetLogger(object self, object logger)
{ 
	HttpRequest_cv->cLogger = logger; 
	return self; 
} 

PMETHOD objrtn initInstance(object self, char *url, char *verb)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	iv->iVerb = gNewWithStr(String, verb); 
	iv->iUrl = gNewWithStr(String, url); 
	iv->iHeaders = gNew(LinkObject); 
	iv->iInternetOpenOptions = gNew(IntegerDictionary); 
	iv->iTimeoutSeconds = 60; 
	return self; 
} 

imeth objrtn HttpRequest_im_gDispose(object self)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	if (iv->iResponseStr) 
		free(iv->iResponseStr); 
	if (iv->iErrorMessage) 
		gDispose(iv->iErrorMessage); 
	if (iv->iUser) 
		gDispose(iv->iUser); 
	if (iv->iPass) 
		gDispose(iv->iPass); 
	if (iv->iVerb) 
		gDispose(iv->iVerb); 
	if (iv->iContent) 
		gDispose(iv->iContent); 
	if (iv->iUrl) 
		gDispose(iv->iUrl); 
	if (iv->iHeaders) 
		gDeepDispose(iv->iHeaders); 
	if (iv->iResponseHeaders) 
		gDeepDispose(iv->iResponseHeaders); 
	if (iv->iOutputFileName) 
		gDispose(iv->iOutputFileName); 
	if (iv->iInternetOpenOptions) 
		gDeepDispose(iv->iInternetOpenOptions); 
	return oSuper(HttpRequest_c, gDispose, self)(self); 
} 

imeth objrtn HttpRequest_im_gSetSecure(object self, int secure)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	iv->iSecure = secure; 
	return self; 
} 

imeth objrtn HttpRequest_im_gSetOutputFileName(object self, char *name)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	if (iv->iOutputFileName) 
		gDispose(iv->iOutputFileName); 
	if (!name) 
		return self; 
	iv->iOutputFileName = gNewWithStr(String, name); 
	return self; 
} 

imeth objrtn HttpRequest_im_gAddHeader(object self, char *name, char *value)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	if (!name || !value) 
		return NULL; 
	gAddLast(iv->iHeaders, vBuild(String, name, ": ", value, END)); 
	return self; 
} 

imeth void HttpRequest_im_gInternetSetOption(object self, int option, char *buffer, int buflen)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	object bufferObj = gNew(String); 
	if (buflen <= 0) 
		buflen = strlen(buffer); 
	gWrite(bufferObj, buffer, buflen); 
	gAddInt(iv->iInternetOpenOptions, option, bufferObj); 
} 

imeth void HttpRequest_im_gInternetSetOptionDirect(object self, int option, void *buffer, int buflen)
{ 
	UNUSED(iv); 
	UNUSED(option); 
	UNUSED(buffer); 
	UNUSED(buflen); 
	gTraceCall(StackTracer); 
	return; 
} 

imeth void HttpRequest_im_gSetCertificate(object self, void *cert)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	iv->iCertificate = cert; 
} 

imeth objrtn HttpRequest_im_gSetContent(object self, char *content)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	if (iv->iContent) 
		iv->iContent = gDispose(iv->iContent); 
	if (!content) 
		return self; 
	iv->iContent = gNewWithStr(String, content); 
	return self; 
} 

imeth objrtn HttpRequest_im_gSetContentFromFile(object self, char *filename)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	FILE *fbuf; 
	char buf[256]; 
	int readCnt; 
	if (iv->iContent) 
		iv->iContent = gDispose(iv->iContent); 
	if (!filename) 
		return NULL; 
	fbuf = fopen(filename, "rb"); 
	if (fbuf == NULL) 
		return NULL; 
	iv->iContent = gNewWithStr(String, ""); 
	while (!feof(fbuf)) { 
		readCnt = fread(buf, 1, sizeof(buf) - 1, fbuf); 
		if (readCnt > 0) { 
			buf[readCnt] = '\0'; 
			gAppend(iv->iContent, (object)buf); 
		} 
	} 

	fclose(fbuf); 
	return self; 
} 

imeth objrtn HttpRequest_im_gSetAuth(object self, char *user, char *pass)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	if (!user || !pass) 
		return NULL; 

	if (iv->iUser) 
		iv->iUser = gDispose(iv->iUser); 
	iv->iUser = gNewWithStr(String, user); 

	if (iv->iPass) 
		iv->iPass = gDispose(iv->iPass); 
	iv->iPass = gNewWithStr(String, pass); 
	return self; 
} 

cmeth int HttpRequest_cm_gPostAndSaveResponseAsFile(object self, char *url, char *contentType, char *content, int flags, char *outputFileName)
{ 
	object req = gNewHttpRequest(HttpRequest, url, "POST"); 
	int res; 
	if (content) { 
		gSetContent(req, content); 
		gAddHeader(req, "Content-Type", contentType ? contentType : "text/plain"); 
	} 
	gSetOutputFileName(req, outputFileName); 
	res = gSendRequest(req, flags); 
	gDispose(req); 
	return res; 
} 

imeth char * HttpRequest_im_gGetErrorMessage(object self)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	if (!iv->iErrorMessage) 
		return NULL; 
	return gStringValue(iv->iErrorMessage); 
} 

imeth char * HttpRequest_im_gGetResponse(object self)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	return iv->iResponseStr; 
} 

imeth void HttpRequest_im_gSetResponseTimeoutSeconds(object self, int seconds)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	iv->iTimeoutSeconds = seconds; 
} 

imeth objrtn HttpRequest_im_gGetResponseHeaders(object self)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	return iv->iResponseHeaders; 
} 

imeth char * HttpRequest_im_gGetResponseHeader(object self, char *headerName)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	object val; 
	char tmpbuf[256]; 
	if (!iv->iResponseHeaders) 
		return NULL; 
	strncpy(tmpbuf, headerName, sizeof(tmpbuf) - 1); 
	val = gFindValueStr(iv->iResponseHeaders, strlwr(tmpbuf)); 
	return val ? gStringValue(val) : NULL; 
} 


static char *strlwr(char *p) 
{ 
	char *r = p; 
	for (; *p ; ++p) 
		*p = tolower(*p); 
	return r; 
} 


struct curl_fetch_st { 
	char *payload; 
	size_t size; 
}; 


static size_t curl_callback (void *contents, size_t size, size_t nmemb, void *userp) 
{ 
	size_t realsize = size * nmemb; 
	struct curl_fetch_st *p = (struct curl_fetch_st *) userp; 


	char * temp = realloc(p->payload, p->size + realsize + 1); 


	if (temp == NULL) { 

		LOG_ERROR(HttpRequest_cv->cLogger, "ERROR: Failed to expand buffer in curl_callback"); 

		free(p->payload); 

		return 1; 
	} 


	p->payload = temp; 


	memcpy(&(p->payload[p->size]), contents, realsize); 


	p->size += realsize; 


	p->payload[p->size] = 0; 


	return realsize; 
} 


static CURLcode fetch_url(CURL *ch, const char *url, struct curl_fetch_st *fetch, long timeoutSeconds) 
{ 
	CURLcode rcode; 
	struct data config; 

	config.trace_ascii = 1; 
	curl_easy_setopt(ch, CURLOPT_DEBUGFUNCTION, my_trace); 
	curl_easy_setopt(ch, CURLOPT_DEBUGDATA, &config); 
	curl_easy_setopt(ch, CURLOPT_VERBOSE, 1L); 

	curl_easy_setopt(ch, CURLOPT_MAXREDIRS, -1L); 
	curl_easy_setopt(ch, CURLOPT_FOLLOWLOCATION, 1L); 
	curl_easy_setopt(ch, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL); 
	curl_easy_setopt(ch, CURLOPT_UNRESTRICTED_AUTH, 1L); 


	fetch->payload = (char *) calloc(1, sizeof(fetch->payload)); 


	if (fetch->payload == NULL) { 

		LOG_ERROR(HttpRequest_cv->cLogger, "ERROR: Failed to allocate payload in fetch_url"); 

		return CURLE_FAILED_INIT; 
	} 


	fetch->size = 0; 


	curl_easy_setopt(ch, CURLOPT_URL, url); 


	curl_easy_setopt(ch, CURLOPT_WRITEFUNCTION, curl_callback); 


	curl_easy_setopt(ch, CURLOPT_WRITEDATA, (void *) fetch); 


	curl_easy_setopt(ch, CURLOPT_USERAGENT, "libcurl-agent/1.0"); 


	curl_easy_setopt(ch, CURLOPT_TIMEOUT, timeoutSeconds); 


	curl_easy_setopt(ch, CURLOPT_FOLLOWLOCATION, 1L); 


	curl_easy_setopt(ch, CURLOPT_MAXREDIRS, 1L); 

	LOG_DEBUG(HttpRequest_cv->cLogger, "About to run curl_easy_perform()"); 

	rcode = curl_easy_perform(ch); 
	LOG_DEBUG(HttpRequest_cv->cLogger, (char *) curl_easy_strerror(rcode)); 


	return rcode; 
} 

PMETHOD int restCall(object self)
{ HttpRequest_iv_t *iv = GetIVs(HttpRequest, self);
	CURL *ch; 
	CURLcode rcode; 

	struct curl_fetch_st curl_fetch; 
	struct curl_fetch_st *cf = &curl_fetch; 
	struct curl_slist *headers = NULL; 
	char *verb = gStringValue(iv->iVerb); 
	object header, seq; 

	curl_fetch.payload = NULL; 
	curl_fetch.size = 0; 


	if ((ch = curl_easy_init()) == NULL) { 
		if (iv->iErrorMessage) 
			gDispose(iv->iErrorMessage); 
		iv->iErrorMessage = gNewWithStr(String, "ERROR: Failed to create curl handle in fetch_session"); 

		LOG_ERROR(HttpRequest_cv->cLogger, "Failed to create curl handle in fetch_session"); 

		return CURLE_FAILED_INIT; 
	} 

	for (seq=gSequence(iv->iHeaders) ; header = gNext(seq) ; ) 
		headers = curl_slist_append(headers, gStringValue(header)); 
	headers = curl_slist_append(headers, "Expect:"); 


	if (!strcmp(verb, "POST")) 
		curl_easy_setopt(ch, CURLOPT_POST, 1L); 
	else if (!strcmp(verb, "GET")) 
		curl_easy_setopt(ch, CURLOPT_HTTPGET, 1L); 
	else if (!strcmp(verb, "PUT")) 
		curl_easy_setopt(ch, CURLOPT_PUT, 1L); 

	curl_easy_setopt(ch, CURLOPT_HTTPHEADER, headers); 
	if (!strcmp(verb, "POST") && iv->iContent) 
		curl_easy_setopt(ch, CURLOPT_POSTFIELDS, gStringValue(iv->iContent)); 


	rcode = fetch_url(ch, gStringValue(iv->iUrl), cf, (long) iv->iTimeoutSeconds); 

	if (rcode != CURLE_OK) { 
		if (iv->iErrorMessage) 
			gDispose(iv->iErrorMessage); 
		iv->iErrorMessage = gNewWithStr(String, (char *) curl_easy_strerror(rcode)); 
		LOG_DEBUG(HttpRequest_cv->cLogger, (char *) curl_easy_strerror(rcode)); 
	} else 
		LOG_DEBUG(HttpRequest_cv->cLogger, "HttpRequestLinux - succeeded"); 


	curl_easy_cleanup(ch); 


	curl_slist_free_all(headers); 


	iv->iResponseStr = cf->payload; 

	return rcode; 
} 

static void class_init() 
{ 
	char logbuf[256]; 
	CURLcode r = curl_global_init(CURL_GLOBAL_ALL); 
	if (r != CURLE_OK) { 
		sprintf(logbuf, "curl_global_init() failed %s", curl_easy_strerror(r)); 
		LOG_ERROR(HttpRequest_cv->cLogger, logbuf); 
	} 
	sprintf(logbuf, "curl version %s", curl_version()); 
	LOG_INFO(HttpRequest_cv->cLogger, logbuf); 
} 

static void dump(const char *text, FILE *stream, unsigned char *ptr, size_t size, char nohex) 
{ 
	size_t i; 
	size_t c; 

	unsigned int width = 0x10; 
	int logLevel = gGetLogLevel(HttpRequest_cv->cLogger); 
	int fd; 

	if (logLevel < LOG_LEVEL_DEBUG) 
		return; 
	fd = gOpenLogFile(HttpRequest_cv->cLogger); 
	if (fd == STDOUT_FILENO) 
		stream = stdout; 
	else if (fd == STDERR_FILENO) 
		stream = stderr; 
	else 
		stream = fdopen(fd, "a"); 

	if (nohex) 

		width = 0x40; 

	fprintf(stream, "%s, %10.10lu bytes (0x%8.8lx)\n", 
		text, (unsigned long)size, (unsigned long)size); 

	for (i = 0; i<size; i += width) { 

		fprintf(stream, "%4.4lx: ", (unsigned long)i); 

		if (!nohex) { 

			for (c = 0; c < width; c++) 
				if (i + c < size) 
				fprintf(stream, "%02x ", ptr[i + c]); 
			else 
				fputs("   ", stream); 
		} 

		for (c = 0; (c < width) && (i + c < size); c++) { 

			if (nohex && (i + c + 1 < size) && ptr[i + c] == 0x0D && 
				ptr[i + c + 1] == 0x0A) { 
				i += (c + 2 - width); 
				break; 
			} 
			fprintf(stream, "%c", 
				(ptr[i + c] >= 0x20) && (ptr[i + c]<0x80)?ptr[i + c]:'.'); 

			if (nohex && (i + c + 2 < size) && ptr[i + c + 1] == 0x0D && 
				ptr[i + c + 2] == 0x0A) { 
				i += (c + 3 - width); 
				break; 
			} 
		} 
		fputc('\n', stream); 
	} 
	fflush(stream); 
	gUnlockLogFile(HttpRequest_cv->cLogger, fd); 
	if (fd != STDOUT_FILENO && fd != STDERR_FILENO) 
		fclose(stream); 
} 

static int my_trace(CURL *handle, curl_infotype type, char *data, size_t size, void *userp) 
{ 
	struct data *config = (struct data *)userp; 
	const char *text; 
	(void)handle; 

	switch(type) { 
		case CURLINFO_TEXT: 
		LOG_DEBUG(HttpRequest_cv->cLogger, data); 

		default: 
		return 0; 

		case CURLINFO_HEADER_OUT: 
		text = "=> Send header"; 
		break; 
		case CURLINFO_DATA_OUT: 
		text = "=> Send data"; 
		break; 
		case CURLINFO_SSL_DATA_OUT: 
		text = "=> Send SSL data"; 
		break; 
		case CURLINFO_HEADER_IN: 
		text = "<= Recv header"; 
		break; 
		case CURLINFO_DATA_IN: 
		text = "<= Recv data"; 
		break; 
		case CURLINFO_SSL_DATA_IN: 
		text = "<= Recv SSL data"; 
		break; 
	} 

	dump(text, stderr, (unsigned char *)data, size, config->trace_ascii); 
	return 0; 
} 

#line 576 "HttpRequest.c"

objrtn	HttpRequest_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (HttpRequest_c) {
		LEAVECRITICALSECTION(cs);
		return HttpRequest_c;
	}
	INHIBIT_THREADER;
	HttpRequest_c = gNewClass(Class, "HttpRequest", sizeof(HttpRequest_iv_t), sizeof(HttpRequest_cv_t), END);
	cMethodFor(HttpRequest, gPostAndSaveResponseAsFile, HttpRequest_cm_gPostAndSaveResponseAsFile);
	cMethodFor(HttpRequest, gNewHttpRequest, HttpRequest_cm_gNewHttpRequest);
	cMethodFor(HttpRequest, gSetLogger, HttpRequest_cm_gSetLogger);
	iMethodFor(HttpRequest, gSetSecure, HttpRequest_im_gSetSecure);
	iMethodFor(HttpRequest, gInternetSetOption, HttpRequest_im_gInternetSetOption);
	iMethodFor(HttpRequest, gSetContent, HttpRequest_im_gSetContent);
	iMethodFor(HttpRequest, gGetResponseHeader, HttpRequest_im_gGetResponseHeader);
	iMethodFor(HttpRequest, gGetResponseHeaders, HttpRequest_im_gGetResponseHeaders);
	iMethodFor(HttpRequest, gInternetSetOptionDirect, HttpRequest_im_gInternetSetOptionDirect);
	iMethodFor(HttpRequest, gSetOutputFileName, HttpRequest_im_gSetOutputFileName);
	iMethodFor(HttpRequest, gGetErrorMessage, HttpRequest_im_gGetErrorMessage);
	iMethodFor(HttpRequest, gSetResponseTimeoutSeconds, HttpRequest_im_gSetResponseTimeoutSeconds);
	iMethodFor(HttpRequest, gDispose, HttpRequest_im_gDispose);
	iMethodFor(HttpRequest, gSetContentFromFile, HttpRequest_im_gSetContentFromFile);
	iMethodFor(HttpRequest, gSetCertificate, HttpRequest_im_gSetCertificate);
	iMethodFor(HttpRequest, gDeepDispose, HttpRequest_im_gDispose);
	iMethodFor(HttpRequest, gGetResponse, HttpRequest_im_gGetResponse);
	iMethodFor(HttpRequest, gSetAuth, HttpRequest_im_gSetAuth);
	iMethodFor(HttpRequest, gAddHeader, HttpRequest_im_gAddHeader);

	HttpRequest_cv = GetCVs(HttpRequest);

	class_init();

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return HttpRequest_c;
}




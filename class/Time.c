/*
  Copyright (c) 1996 Blake McBride
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/



/*  This file automatically generated by dpp - do not edit  */

#define	DPP_STRATEGY	2
#define	DPP_FASTWIDE	0




#define	CLASS	Time_c
#define	ivType	Time_iv_t

#include "generics.h"

object	Time_c;


#line 48 "Time.c"
typedef struct  _Time_iv_t  {
	long iVal;
}	Time_iv_t;


#line 36 "Time.d"
#include <string.h> 
#include <math.h> 
#ifndef __COSMIC__ 
#include <time.h> 
#endif 


#line 41 "Time.d"
#ifdef _WIN32 
#include <sys/timeb.h> 
#endif 


#line 45 "Time.d"
#define GET_HOURS(t) (t / 10000000L) 
#define GET_MINUTES(t) ((t / 100000L) % 100L) 
#define GET_SECONDS(t) ((t / 1000L) % 100L) 
#define GET_MILLI(t) (t % 1000) 
#define BUILD_TIME(h, m, s, l) (((long) h * 10000000L) + ((long) m * 100000L) + ((long) s * 1000) + (long) l) 

static long Time_hmsl(long tm, int *h, int *m, int *s, int *l) 
{ 
	if (h) 
		*h = GET_HOURS(tm); 
	if (m) 
		*m = GET_MINUTES(tm); 
	if (s) 
		*s = GET_SECONDS(tm); 
	if (l) 
		*l = GET_MILLI(tm); 

	return tm; 
} 

static long toMilli(long tm) 
{ 
	int h, m, s, l; 

	Time_hmsl(tm, &h, &m, &s, &l); 

	return ((long) h * 3600000L) + ((long) m * 60000L) + ((long) s * 1000L) + (long) l; 
} 

static long fromMilli(long ms) 
{ 
	int h, m, s, l; 

	ms %= 86400000L; 
	if (ms < 0) 
		ms += 86400000L; 

	h = (int) (ms / 3600000L); 
	ms %= 3600000L; 
	m = (int) (ms / 60000L); 
	ms %= 60000L; 
	s = (int) (ms / 1000L); 
	l = (int) (ms % 1000L); 

	return BUILD_TIME(h, m, s, l); 
} 

static long Add_hours(long tm, long hrs) 
{ 
	long ms = toMilli(tm); 
	long ha = hrs * 3600000L; 

	return fromMilli(ms + ha); 
} 

static long Add_minutes(long tm, long min) 
{ 
	long ms = toMilli(tm); 
	long ma = min * 60000L; 

	return fromMilli(ms + ma); 
} 

static long Add_seconds(long tm, long sec) 
{ 
	long ms = toMilli(tm); 
	long sa = sec * 1000L; 

	return fromMilli(ms + sa); 
} 

static long Add_milliseconds(long tm, long msec) 
{ 
	return fromMilli(toMilli(tm) + msec); 
} 

static int Valid_time(long tm) 
{ 
	int h, m, s, l; 

	Time_hmsl(tm, &h, &m, &s, &l); 

	if (h < 0 || h >= 24) 
		return 0; 
	if (m < 0 || m >= 60) 
		return 0; 
	if (s < 0 || s >= 60) 
		return 0; 
	if (l < 0 || l >= 1000) 
		return 0; 
	return 1; 
} 

static short *Timemark(short int *v) 
{ 
#if defined(_WIN32) && !defined(__MINGW32__) && !defined(__WINE__) 
	SYSTEMTIME st; 

	GetLocalTime(&st); 
	v[0] = st.wYear; 
	v[1] = st.wMonth; 
	v[2] = st.wDay; 
	v[3] = st.wHour; 
	v[4] = st.wMinute; 
	v[5] = st.wSecond; 
	v[6] = st.wMilliseconds; 
#else 


#line 152 "Time.d"
#ifdef PLAN9 
	Tm *a; 
	time_t t; 
	time(&t); 
	a = localtime(t); 
	v[0] = a->year + 1900; 
	v[1] = a->mon + 1; 
	v[2] = a->mday; 
	v[3] = a->hour; 
	v[4] = a->min; 
	v[5] = a->sec; 
	v[6] = 0; 
#else 


#line 165 "Time.d"
	struct tm *a; 
	time_t t; 
	time(&t); 
	a = localtime(&t); 
	v[0] = a->tm_year + 1900; 
	v[1] = a->tm_mon + 1; 
	v[2] = a->tm_mday; 
	v[3] = a->tm_hour; 
	v[4] = a->tm_min; 
	v[5] = a->tm_sec; 
	v[6] = 0; 
#endif 


#line 177 "Time.d"
#endif 


#line 178 "Time.d"
	return v; 
} 

static long getNow(void) 
{ 
	short v[7]; 

	Timemark(v); 

	return BUILD_TIME(v[3], v[4], v[5], v[6]); 
} 

static char *Tmfmt(long t, char *s) 
{ 
	int h = GET_HOURS(t); 
	char *p; 

	if (h < 12) { 
		if (!h) 
			h += 12; 
		p = "am"; 
	} else { 
		if (h > 12) 
			h -= 12; 
		p = "pm"; 
	} 

	sprintf(s, "%d:%02d:%02d.%03d%s", h, (int) GET_MINUTES(t), (int) GET_SECONDS(t), (int) GET_MILLI(t), p); 
	return s; 
} 

static char *TimeFmt(char *buf, long tm, char *msk) 
{ 
	int h, m, s, l; 
	char *bp = buf; 
	int temp; 

	if (tm < 0L) { 
		*buf = '\0'; 
		return(buf); 
	} 
	Time_hmsl(tm, &h, &m, &s, &l); 
	while (*msk) 
		if (*msk != '%') 
		*bp++ = *msk++; 
	else 
		switch (*++msk) { 
		case '\0': 
		break; 
		case '%': 
		default: 
		*bp++ = *msk++; 
		break; 
		case 'G': 
		sprintf(bp, "%02d", h); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'g': 
		sprintf(bp, "%d", h); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'H': 
		if (!h) 
			temp = 12; 
		else if (h > 12) 
			temp = h - 12; 
		else 
			temp = h; 
		sprintf(bp, "%02d", temp); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'h': 
		if (!h) 
			temp = 12; 
		else if (h > 12) 
			temp = h - 12; 
		else 
			temp = h; 
		sprintf(bp, "%d", temp); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'M': 
		sprintf(bp, "%02d", m); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'm': 
		sprintf(bp, "%d", m); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'S': 
		sprintf(bp, "%02d", s); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 's': 
		sprintf(bp, "%d", s); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'L': 
		sprintf(bp, "%03d", l); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'l': 
		sprintf(bp, "%d", l); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'P': 
		strcpy(bp, h >= 12 ? "PM" : "AM"); 
		bp += strlen(bp); 
		msk++; 
		break; 
		case 'p': 
		strcpy(bp, h >= 12 ? "pm" : "am"); 
		bp += strlen(bp); 
		msk++; 
		break; 
	} 
	*bp = '\0'; 
	return(buf); 
} 

static long Time_dif(long t1, long t2) 
{ 
	long dif; 
	int x = GET_HOURS(t1) - GET_HOURS(t2); 

	dif = (long) x * 3600000L; 
	x = GET_MINUTES(t1) - GET_MINUTES(t2); 
	dif += ((long) x * 60000L); 
	x = GET_SECONDS(t1) - GET_SECONDS(t2); 
	dif += ((long) x * 1000L); 
	dif += (GET_MILLI(t1) - GET_MILLI(t2)); 

	return dif; 
} 

cmeth objrtn Time_cm_gNewWithLong(object self, long val)
{ 
	object obj = oSuper(Time_c, gNew, self)(self); 
	accessIVsOf(obj); 

	iv->iVal = val; 
	return(obj); 
} 

cmeth objrtn Time_cm_gNewWithStr(object self, char *tmStr)
{ 



	long tm = 0; 

	if (tmStr) { 
		int hour=(tmStr[0]-'0')*10+(tmStr[1]-'0'); 
		int minute=(tmStr[3]-'0')*10+(tmStr[4]-'0'); 
		int second=(tmStr[6]-'0')*10+(tmStr[7]-'0'); 
		int milli=0; 

		if (strlen(tmStr) > 10) 
			milli = (tmStr[9]-'0')*100+(tmStr[10]-'0')*10+(tmStr[11]-'0'); 

		tm = BUILD_TIME(hour, minute, second, milli); 
	} 
	return gNewWithLong(self, tm); 
} 

imeth int Time_im_gHash(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	double t; 

	t = .6125423371 * (unsigned long) iv->iVal; 
	t = t < 0.0 ? -t : t; 
	return (int) (BIG_INT * (t - floor(t))); 
} 

imeth int Time_im_gCompare(object self, object obj)
{ Time_iv_t *iv = GetIVs(Time, self);
	long sv, ov; 

	ChkArg(obj, 2); 
	if ((sv=iv->iVal) < (ov=ivPtr(obj)->iVal)) 
		return -1; 
	else if (sv == ov) 
		return 0; 
	else 
		return 1; 
} 

imeth long Time_im_gLongValue(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return (long) iv->iVal; 
} 

imeth void * Time_im_gPointerValue(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return (void *) &iv->iVal; 
} 

imeth objrtn Time_im_gChangeValue(object self, object val)
{ Time_iv_t *iv = GetIVs(Time, self);
	ChkArg(val, 2); 
	iv->iVal = gLongValue(val); 
	return self; 
} 

imeth objrtn Time_im_gChangeLongValue(object self, long val)
{ Time_iv_t *iv = GetIVs(Time, self);
	iv->iVal = (long) val; 
	return self; 
} 

imeth int Time_im_gHours(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return GET_HOURS(iv->iVal); 
} 

imeth int Time_im_gMinutes(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return GET_MINUTES(iv->iVal); 
} 

imeth int Time_im_gSeconds(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return GET_SECONDS(iv->iVal); 
} 

imeth int Time_im_gMilliseconds(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return GET_MILLI(iv->iVal); 
} 

imeth objrtn Time_im_gFormatTime(object self, char *msk)
{ Time_iv_t *iv = GetIVs(Time, self);
	char buf[80]; 

	return gNewWithStr(String, TimeFmt(buf, iv->iVal, msk)); 
} 

imeth objrtn Time_im_gStringRepValue(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	char buf[25]; 

	return gNewWithStr(String, Tmfmt(iv->iVal, buf)); 
} 

cmeth objrtn Time_cm_gNow(object self)
{ 
	return gNewWithLong(self, getNow()); 
} 

imeth objrtn Time_im_gAddHours(object self, long h)
{ Time_iv_t *iv = GetIVs(Time, self);
	iv->iVal = Add_hours(iv->iVal, h); 
	return self; 
} 

imeth objrtn Time_im_gAddMinutes(object self, long m)
{ Time_iv_t *iv = GetIVs(Time, self);
	iv->iVal = Add_minutes(iv->iVal, m); 
	return self; 
} 

imeth objrtn Time_im_gAddSeconds(object self, long s)
{ Time_iv_t *iv = GetIVs(Time, self);
	iv->iVal = Add_seconds(iv->iVal, s); 
	return self; 
} 

imeth objrtn Time_im_gAddMilliseconds(object self, long l)
{ Time_iv_t *iv = GetIVs(Time, self);
	iv->iVal = Add_milliseconds(iv->iVal, l); 
	return self; 
} 

imeth int Time_im_gValidTime(object self)
{ Time_iv_t *iv = GetIVs(Time, self);
	return Valid_time(iv->iVal); 
} 

imeth long Time_im_gDifference(object self, object tm)
{ Time_iv_t *iv = GetIVs(Time, self);
	ChkArgTyp(tm, 2, Time); 
	return Time_dif(iv->iVal, ivPtr(tm)->iVal); 
} 


#line 509 "Time.c"

objrtn	Time_initialize(void)
{
	static  CRITICALSECTION  cs;
	static  int volatile once = 0;

	ENTERCRITICALSECTION(_CI_CS_);
	if (!once) {
		INITIALIZECRITICALSECTION(cs);
		once = 1;
	}
	LEAVECRITICALSECTION(_CI_CS_);

	ENTERCRITICALSECTION(cs);

	if (Time_c) {
		LEAVECRITICALSECTION(cs);
		return Time_c;
	}
	INHIBIT_THREADER;
	Time_c = gNewClass(Class, "Time", sizeof(Time_iv_t), 0, END);
	cMethodFor(Time, gNewWithStr, Time_cm_gNewWithStr);
	cMethodFor(Time, gNow, Time_cm_gNow);
	cMethodFor(Time, gNewWithLong, Time_cm_gNewWithLong);
	iMethodFor(Time, gAddMinutes, Time_im_gAddMinutes);
	iMethodFor(Time, gMinutes, Time_im_gMinutes);
	iMethodFor(Time, gAddMilliseconds, Time_im_gAddMilliseconds);
	iMethodFor(Time, gSeconds, Time_im_gSeconds);
	iMethodFor(Time, gCompare, Time_im_gCompare);
	iMethodFor(Time, gChangeLongValue, Time_im_gChangeLongValue);
	iMethodFor(Time, gAddSeconds, Time_im_gAddSeconds);
	iMethodFor(Time, gPointerValue, Time_im_gPointerValue);
	iMethodFor(Time, gTimeValue, Time_im_gLongValue);
	iMethodFor(Time, gHours, Time_im_gHours);
	iMethodFor(Time, gMilliseconds, Time_im_gMilliseconds);
	iMethodFor(Time, gValidTime, Time_im_gValidTime);
	iMethodFor(Time, gTimeDifference, Time_im_gDifference);
	iMethodFor(Time, gAddHours, Time_im_gAddHours);
	iMethodFor(Time, gFormatTime, Time_im_gFormatTime);
	iMethodFor(Time, gDifference, Time_im_gDifference);
	iMethodFor(Time, gStringRepValue, Time_im_gStringRepValue);
	iMethodFor(Time, gHash, Time_im_gHash);
	iMethodFor(Time, gChangeTimeValue, Time_im_gChangeLongValue);
	iMethodFor(Time, gChangeValue, Time_im_gChangeValue);
	iMethodFor(Time, gLongValue, Time_im_gLongValue);
	iMethodFor(Time, gTimeStringRepValue, Time_im_gStringRepValue);

	ENABLE_THREADER;

	LEAVECRITICALSECTION(cs);

	return Time_c;
}



